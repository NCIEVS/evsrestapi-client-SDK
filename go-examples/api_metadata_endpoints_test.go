/*
NCI EVS Rest API

Testing MetadataEndpointsAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package evs

import (
	"context"
	"fmt"
	"encoding/json"
	"strings"
	"testing"

	openapiclient "github.com/GIT_USER_ID/GIT_REPO_ID"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMetadataEndpointsAPIService(t *testing.T) {

	configuration := openapiclient.NewConfiguration()
	apiClient := openapiclient.NewAPIClient(configuration)
	terminology := "ncit"

	t.Run("GetAssociationByCode", func(t *testing.T) {

		// ARRANGE
		codeOrName := "A18"
		include := "minimal"
		expectedName := "Has_Pharmaceutical_Basic_Dose_Form"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetAssociation(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetAssociations", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode := "A1"
		expectedSize := 35
		containsExpectedCode := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetAssociations(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.GreaterOrEqual(t, len(resp), expectedSize)

		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode) {
				containsExpectedCode = true
				break
			}
		}

		assert.True(t, containsExpectedCode, "FAIL: expected code not found in associations")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetConceptStatuses", func(t *testing.T) {

		// ARRANGE
		expectedStatus := "Obsolete_Concept"
		expectedSize := 5
		containsExpectedStatus := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetConceptStatuses(context.Background(), terminology).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedSize, len(resp))

		for _, status := range resp {
			assert.NotNil(t, status)
			if strings.Contains(status, expectedStatus) {
				containsExpectedStatus = true
				break
			}
		}

		assert.True(t, containsExpectedStatus, "FAIL: expected status not found in concept statuses")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetDefinitionSources", func(t *testing.T) {

		// ARRANGE
		expectedName := "American College of Cardiology / American Heart Association"
		expectedCode := "ACC/AHA"
		containsExpectedValues := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetDefinitionSources(context.Background(), terminology).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, definitionSource := range resp {
			assert.NotNil(t, definitionSource.GetCode())
			assert.NotNil(t, definitionSource.GetName())
			if strings.Contains(definitionSource.GetCode(), expectedCode) &&
				strings.Contains(definitionSource.GetName(), expectedName) {
				containsExpectedValues = true
				break
			}
		}

		assert.True(t, containsExpectedValues, "FAIL: expected definition source not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetDefinitionTypeByCode", func(t *testing.T) {

		// ARRANGE
		codeOrName := "P325"
		include := "minimal"
		expectedName := "ALT_DEFINITION"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetDefinitionType(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetDefinitionTypes", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode := "P97"
		expectedName := "DEFINITION"
		containsExpectedValues := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetDefinitionTypes(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			assert.NotNil(t, concept.GetName())
			if strings.Contains(concept.GetCode(), expectedCode) && strings.Contains(concept.GetName(), expectedName) {
				containsExpectedValues = true
				break
			}
		}

		assert.True(t, containsExpectedValues, "FAIL: expected definition type not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetProperties", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode := "NHC0"
		expectedName := "code"
		containsExpectedValues := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetProperties(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			assert.NotNil(t, concept.GetName())
			if strings.Contains(concept.GetCode(), expectedCode) && strings.Contains(concept.GetName(), expectedName) {
				containsExpectedValues = true
				break
			}
		}

		assert.True(t, containsExpectedValues, "FAIL: expected property not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetProperty", func(t *testing.T) {

		// ARRANGE
		codeOrName := "P216"
		include := "full"
		expectedName := "BioCarta_ID"
		expectedSynonym := "BioCarta ID"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetProperty(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
		assert.Equal(t, expectedSynonym, resp.GetSynonyms()[0].GetName(), "FAIL: expected synonym doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetQualifier", func(t *testing.T) {

		// ARRANGE
		codeOrName := "P390"
		include := "summary"
		expectedName := "go-source"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetQualifier(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.NotNil(t, resp.GetSynonyms())
		assert.NotNil(t, resp.GetDefinitions())
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetQualifierValues", func(t *testing.T) {

		// ARRANGE
		codeOrName := "P390"
		expectedValue := "CGAP"
		containsExpectedValue := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetQualifierValues(context.Background(), terminology, codeOrName).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, value := range resp {
			assert.NotNil(t, value)
			if strings.Contains(value, expectedValue) {
				containsExpectedValue = true
				break
			}
		}

		assert.True(t, containsExpectedValue, "FAIL: expected value not found in qualifier values")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetQualifiers", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode1 := "P383"
		expectedCode2 := "P384"
		containsCode1 := false
		containsCode2 := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetQualifiers(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, qualifier := range resp {
			assert.NotNil(t, qualifier.GetCode())
			if strings.Contains(qualifier.GetCode(), expectedCode1) {
				containsCode1 = true
			}
			if strings.Contains(qualifier.GetCode(), expectedCode2) {
				containsCode2 = true
			}
			if containsCode1 && containsCode2 {
				break
			}
		}

		assert.True(t, containsCode1, "FAIL: expected code 1 not found")
		assert.True(t, containsCode2, "FAIL: expected code 2 not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetRole", func(t *testing.T) {

		// ARRANGE
		codeOrName := "R123"
		include := "full"
		expectedName := "Chemotherapy_Regimen_Has_Component"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetRole(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		assert.NotNil(t, resp.GetSynonyms())
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetRoles", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode := "R123"
		containsExpectedCode := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetRoles(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode) {
				containsExpectedCode = true
				break
			}
		}

		assert.True(t, containsExpectedCode, "FAIL: expected code not found in roles")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetSubsets1", func(t *testing.T) {

		// ARRANGE
		include := "minimal"
		expectedCode := "C167405"
		containsExpectedCode := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetSubsets1(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode) {
				containsExpectedCode = true
				break
			}
		}

		assert.True(t, containsExpectedCode, "FAIL: expected code not found in subsets")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetSubset1", func(t *testing.T) {

		// ARRANGE
		code := "C81222"
		include := "summary"
		expectedName := "CDISC ADaM Terminology"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetSubset1(context.Background(), terminology, code).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetSynonymSources", func(t *testing.T) {

		// ARRANGE
		expectedCode1 := "ACC/AHA"
		expectedCode2 := "BIOCARTA"
		containsCode1 := false
		containsCode2 := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetSynonymSources(context.Background(), terminology).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode1) {
				containsCode1 = true
			}
			if strings.Contains(concept.GetCode(), expectedCode2) {
				containsCode2 = true
			}
			if containsCode1 && containsCode2 {
				break
			}
		}

		assert.True(t, containsCode1, "FAIL: expected code 1 not found")
		assert.True(t, containsCode2, "FAIL: expected code 2 not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetSynonymTypeByCode", func(t *testing.T) {

		// ARRANGE
		codeOrName := "P90"
		include := "minimal"
		expectedName := "FULL_SYN"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetSynonymType(context.Background(), terminology, codeOrName).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, expectedName, resp.GetName(), "FAIL: expected name doesn't match actual")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetSynonymTypes", func(t *testing.T) {

		// ARRANGE
		include := "full"
		expectedCode := "P108"
		containsExpectedCode := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetSynonymTypes(context.Background(), terminology).
			Include(include).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode) {
				containsExpectedCode = true
				break
			}
		}

		assert.True(t, containsExpectedCode, "FAIL: expected code not found in synonym types")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetTermTypes", func(t *testing.T) {

		// ARRANGE
		expectedCode1 := "AB"
		expectedCode2 := "AD"
		containsCode1 := false
		containsCode2 := false

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetTermTypes(context.Background(), terminology).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		for _, concept := range resp {
			assert.NotNil(t, concept.GetCode())
			if strings.Contains(concept.GetCode(), expectedCode1) {
				containsCode1 = true
			}
			if strings.Contains(concept.GetCode(), expectedCode2) {
				containsCode2 = true
			}
			if containsCode1 && containsCode2 {
				break
			}
		}

		assert.True(t, containsCode1, "FAIL: expected code 1 not found")
		assert.True(t, containsCode2, "FAIL: expected code 2 not found")
	
		result, err := json.Marshal(resp)
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Printf("%s", result)
	})

	t.Run("GetTerminologies", func(t *testing.T) {

		// ARRANGE
		latest := true
		tag := "monthly"

		// ACT
		resp, httpRes, err := apiClient.MetadataEndpointsAPI.GetTerminologies(context.Background()).
			Latest(latest).Tag(tag).Execute()

		// ASSERT
		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)
		assert.Equal(t, terminology, resp[0].GetTerminology(), "FAIL: expected terminology doesn't match actual")
		assert.True(t, resp[0].GetLatest())
		
		result, err := resp[0].MarshalJSON()
		require.Nil(t, err)
		require.NotNil(t, result)
		fmt.Println(string(result))
	})

}

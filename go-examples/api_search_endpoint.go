/*
NCI EVS Rest API

Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>

API version: 1.7.2.RELEASE
Contact: NCIAppSupport@nih.gov
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SearchEndpointAPIService SearchEndpointAPI service
type SearchEndpointAPIService service

type ApiGetSparqlBindingsRequest struct {
	ctx context.Context
	ApiService *SearchEndpointAPIService
	terminology string
	body *string
	fromRecord *int32
	pageSize *int32
	xEVSRESTAPILicenseKey *string
}

// SPARQL query to execute on the graph for the specified terminology. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/SPARQL.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for more information and examples of using SPARQL with EVSRESTAPI&lt;/a&gt;.
func (r ApiGetSparqlBindingsRequest) Body(body string) ApiGetSparqlBindingsRequest {
	r.body = &body
	return r
}

// Start index of the search results
func (r ApiGetSparqlBindingsRequest) FromRecord(fromRecord int32) ApiGetSparqlBindingsRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetSparqlBindingsRequest) PageSize(pageSize int32) ApiGetSparqlBindingsRequest {
	r.pageSize = &pageSize
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetSparqlBindingsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetSparqlBindingsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetSparqlBindingsRequest) Execute() (*MapResultList, *http.Response, error) {
	return r.ApiService.GetSparqlBindingsExecute(r)
}

/*
GetSparqlBindings Get SPARQL query results

Perform a SPARQL query for a specified terminology.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Single terminology to search, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @return ApiGetSparqlBindingsRequest
*/
func (a *SearchEndpointAPIService) GetSparqlBindings(ctx context.Context, terminology string) ApiGetSparqlBindingsRequest {
	return ApiGetSparqlBindingsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return MapResultList
func (a *SearchEndpointAPIService) GetSparqlBindingsExecute(r ApiGetSparqlBindingsRequest) (*MapResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MapResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchEndpointAPIService.GetSparqlBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sparql/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRequest struct {
	ctx context.Context
	ApiService *SearchEndpointAPIService
	xEVSRESTAPILicenseKey *string
	terminology *string
	term *string
	type_ *string
	sort *string
	ascending *bool
	include *string
	fromRecord *int32
	pageSize *int32
	conceptStatus *string
	property *string
	value *string
	definitionSource *string
	definitionType *string
	synonymSource *string
	synonymType *string
	synonymTermType *string
	subset *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiSearchRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

// Comma-separated list of terminologies to search, e.g. &#39;ncit&#39; or &#39;ncim&#39; (&lt;a href&#x3D;\&quot;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\&quot;&gt;See here for complete list&lt;/a&gt;)
func (r ApiSearchRequest) Terminology(terminology string) ApiSearchRequest {
	r.terminology = &terminology
	return r
}

// The term, phrase, or code to be searched, e.g. &#39;melanoma&#39;
func (r ApiSearchRequest) Term(term string) ApiSearchRequest {
	r.term = &term
	return r
}

// The match type, one of: contains, match, startsWith, phrase, AND, OR, fuzzy.
func (r ApiSearchRequest) Type_(type_ string) ApiSearchRequest {
	r.type_ = &type_
	return r
}

// The search parameter to sort results by
func (r ApiSearchRequest) Sort(sort string) ApiSearchRequest {
	r.sort = &sort
	return r
}

// Sort ascending (if true) or descending (if false)
func (r ApiSearchRequest) Ascending(ascending bool) ApiSearchRequest {
	r.ascending = &ascending
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchRequest) Include(include string) ApiSearchRequest {
	r.include = &include
	return r
}

// Start index of the search results
func (r ApiSearchRequest) FromRecord(fromRecord int32) ApiSearchRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiSearchRequest) PageSize(pageSize int32) ApiSearchRequest {
	r.pageSize = &pageSize
	return r
}

// Comma-separated list of concept status values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/conceptStatuses&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchRequest) ConceptStatus(conceptStatus string) ApiSearchRequest {
	r.conceptStatus = &conceptStatus
	return r
}

// Comma-separated list of properties to restrict search results by (see also &lt;i&gt;value&lt;/i&gt;). e.g.&lt;ul&gt;&lt;li&gt;&#39;P106,P322&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&#39;COLOR,SHAPE&#39; for &lt;i&gt;terminology&#x3D;ncim&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus properties&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus properties&lt;/a&gt;.&lt;/p&gt; The properties can be specified as code or name. NOTE: This feature works with &lt;i&gt;value&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching the &lt;i&gt;value&lt;/i&gt; parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchRequest) Property(property string) ApiSearchRequest {
	r.property = &property
	return r
}

// A property value to restrict search results by.  NOTE: This feature works with &lt;i&gt;property&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching this parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchRequest) Value(value string) ApiSearchRequest {
	r.value = &value
	return r
}

// Comma-separated list of definition sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchRequest) DefinitionSource(definitionSource string) ApiSearchRequest {
	r.definitionSource = &definitionSource
	return r
}

// Comma-separated list of definition types to restrict search results by, e.g. &#39;DEFINITION,ALT_DEFINITION&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchRequest) DefinitionType(definitionType string) ApiSearchRequest {
	r.definitionType = &definitionType
	return r
}

// Comma-separated list of synonym sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchRequest) SynonymSource(synonymSource string) ApiSearchRequest {
	r.synonymSource = &synonymSource
	return r
}

// Comma-separated list of synonym types to restrict search results by, e.g. &#39;FULL_SYN&#39;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchRequest) SynonymType(synonymType string) ApiSearchRequest {
	r.synonymType = &synonymType
	return r
}

// Comma-separated list of synonym term type values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchRequest) SynonymTermType(synonymTermType string) ApiSearchRequest {
	r.synonymTermType = &synonymTermType
	return r
}

// Comma-separated list of subsets to restrict search results by, e.g. &#39;C157225&#39;. The value &#39;*&#39; can also be used to return results that participate in at least one subset. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;
func (r ApiSearchRequest) Subset(subset string) ApiSearchRequest {
	r.subset = &subset
	return r
}

func (r ApiSearchRequest) Execute() (*ConceptResultList, *http.Response, error) {
	return r.ApiService.SearchExecute(r)
}

/*
Search Get concept search results

Use cases for search range from very simple term searches, use of paging parameters, additional filters, searches properties, roles, and associations, and so on.  To further explore the range of search options, take a look at the <a href='https://github.com/NCIEVS/evsrestapi-client-SDK' target='_blank'>Github client SDK library created for the NCI EVS Rest API</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRequest
*/
func (a *SearchEndpointAPIService) Search(ctx context.Context) ApiSearchRequest {
	return ApiSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConceptResultList
func (a *SearchEndpointAPIService) SearchExecute(r ApiSearchRequest) (*ConceptResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConceptResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchEndpointAPIService.Search")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.terminology != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminology", r.terminology, "")
	}
	if r.term != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.conceptStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conceptStatus", r.conceptStatus, "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	if r.definitionSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionSource", r.definitionSource, "")
	}
	if r.definitionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionType", r.definitionType, "")
	}
	if r.synonymSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymSource", r.synonymSource, "")
	}
	if r.synonymType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymType", r.synonymType, "")
	}
	if r.synonymTermType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymTermType", r.synonymTermType, "")
	}
	if r.subset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subset", r.subset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSingleTerminologyRequest struct {
	ctx context.Context
	ApiService *SearchEndpointAPIService
	terminology string
	xEVSRESTAPILicenseKey *string
	term *string
	type_ *string
	sort *string
	ascending *bool
	include *string
	fromRecord *int32
	pageSize *int32
	conceptStatus *string
	property *string
	value *string
	definitionSource *string
	definitionType *string
	synonymSource *string
	synonymType *string
	synonymTermType *string
	subset *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchSingleTerminologyRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiSearchSingleTerminologyRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

// The term, phrase, or code to be searched, e.g. &#39;melanoma&#39;
func (r ApiSearchSingleTerminologyRequest) Term(term string) ApiSearchSingleTerminologyRequest {
	r.term = &term
	return r
}

// The match type, one of: contains, match, startsWith, phrase, AND, OR, fuzzy.
func (r ApiSearchSingleTerminologyRequest) Type_(type_ string) ApiSearchSingleTerminologyRequest {
	r.type_ = &type_
	return r
}

// The search parameter to sort results by
func (r ApiSearchSingleTerminologyRequest) Sort(sort string) ApiSearchSingleTerminologyRequest {
	r.sort = &sort
	return r
}

// Sort ascending (if true) or descending (if false)
func (r ApiSearchSingleTerminologyRequest) Ascending(ascending bool) ApiSearchSingleTerminologyRequest {
	r.ascending = &ascending
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchSingleTerminologyRequest) Include(include string) ApiSearchSingleTerminologyRequest {
	r.include = &include
	return r
}

// Start index of the search results
func (r ApiSearchSingleTerminologyRequest) FromRecord(fromRecord int32) ApiSearchSingleTerminologyRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiSearchSingleTerminologyRequest) PageSize(pageSize int32) ApiSearchSingleTerminologyRequest {
	r.pageSize = &pageSize
	return r
}

// Comma-separated list of concept status values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/conceptStatuses&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) ConceptStatus(conceptStatus string) ApiSearchSingleTerminologyRequest {
	r.conceptStatus = &conceptStatus
	return r
}

// Comma-separated list of properties to restrict search results by (see also &lt;i&gt;value&lt;/i&gt;). e.g.&lt;ul&gt;&lt;li&gt;&#39;P106,P322&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&#39;COLOR,SHAPE&#39; for &lt;i&gt;terminology&#x3D;ncim&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus properties&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus properties&lt;/a&gt;.&lt;/p&gt; The properties can be specified as code or name. NOTE: This feature works with &lt;i&gt;value&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching the &lt;i&gt;value&lt;/i&gt; parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchSingleTerminologyRequest) Property(property string) ApiSearchSingleTerminologyRequest {
	r.property = &property
	return r
}

// A property value to restrict search results by.  NOTE: This feature works with &lt;i&gt;property&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching this parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchSingleTerminologyRequest) Value(value string) ApiSearchSingleTerminologyRequest {
	r.value = &value
	return r
}

// Comma-separated list of definition sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) DefinitionSource(definitionSource string) ApiSearchSingleTerminologyRequest {
	r.definitionSource = &definitionSource
	return r
}

// Comma-separated list of definition types to restrict search results by, e.g. &#39;DEFINITION,ALT_DEFINITION&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) DefinitionType(definitionType string) ApiSearchSingleTerminologyRequest {
	r.definitionType = &definitionType
	return r
}

// Comma-separated list of synonym sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) SynonymSource(synonymSource string) ApiSearchSingleTerminologyRequest {
	r.synonymSource = &synonymSource
	return r
}

// Comma-separated list of synonym types to restrict search results by, e.g. &#39;FULL_SYN&#39;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) SynonymType(synonymType string) ApiSearchSingleTerminologyRequest {
	r.synonymType = &synonymType
	return r
}

// Comma-separated list of synonym term type values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologyRequest) SynonymTermType(synonymTermType string) ApiSearchSingleTerminologyRequest {
	r.synonymTermType = &synonymTermType
	return r
}

// Comma-separated list of subsets to restrict search results by, e.g. &#39;C157225&#39;. The value &#39;*&#39; can also be used to return results that participate in at least one subset. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;
func (r ApiSearchSingleTerminologyRequest) Subset(subset string) ApiSearchSingleTerminologyRequest {
	r.subset = &subset
	return r
}

func (r ApiSearchSingleTerminologyRequest) Execute() (*ConceptResultList, *http.Response, error) {
	return r.ApiService.SearchSingleTerminologyExecute(r)
}

/*
SearchSingleTerminology Get concept search results for a specified terminology

Use cases for search range from very simple term searches, use of paging parameters, additional filters, searches properties, roles, and associations, and so on.  To further explore the range of search options, take a look at the <a href='https://github.com/NCIEVS/evsrestapi-client-SDK' target='_blank'>Github client SDK library created for the NCI EVS Rest API</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Single terminology to search, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @return ApiSearchSingleTerminologyRequest
*/
func (a *SearchEndpointAPIService) SearchSingleTerminology(ctx context.Context, terminology string) ApiSearchSingleTerminologyRequest {
	return ApiSearchSingleTerminologyRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ConceptResultList
func (a *SearchEndpointAPIService) SearchSingleTerminologyExecute(r ApiSearchSingleTerminologyRequest) (*ConceptResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConceptResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchEndpointAPIService.SearchSingleTerminology")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.term != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.conceptStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conceptStatus", r.conceptStatus, "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	if r.definitionSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionSource", r.definitionSource, "")
	}
	if r.definitionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionType", r.definitionType, "")
	}
	if r.synonymSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymSource", r.synonymSource, "")
	}
	if r.synonymType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymType", r.synonymType, "")
	}
	if r.synonymTermType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymTermType", r.synonymTermType, "")
	}
	if r.subset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subset", r.subset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSingleTerminologySparqlRequest struct {
	ctx context.Context
	ApiService *SearchEndpointAPIService
	terminology string
	body *string
	include *string
	xEVSRESTAPILicenseKey *string
	term *string
	type_ *string
	sort *string
	ascending *bool
	fromRecord *int32
	pageSize *int32
	conceptStatus *string
	property *string
	value *string
	definitionSource *string
	definitionType *string
	synonymSource *string
	synonymType *string
	synonymTermType *string
	subset *string
}

// SPARQL query that returns ?code identifying a valid code in the specified terminology. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/SPARQL.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for more information and examples of using SPARQL with EVSRESTAPI&lt;/a&gt;.
func (r ApiSearchSingleTerminologySparqlRequest) Body(body string) ApiSearchSingleTerminologySparqlRequest {
	r.body = &body
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchSingleTerminologySparqlRequest) Include(include string) ApiSearchSingleTerminologySparqlRequest {
	r.include = &include
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiSearchSingleTerminologySparqlRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiSearchSingleTerminologySparqlRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

// The term, phrase, or code to be searched, e.g. &#39;melanoma&#39;
func (r ApiSearchSingleTerminologySparqlRequest) Term(term string) ApiSearchSingleTerminologySparqlRequest {
	r.term = &term
	return r
}

// The match type, one of: contains, match, startsWith, phrase, AND, OR, fuzzy.
func (r ApiSearchSingleTerminologySparqlRequest) Type_(type_ string) ApiSearchSingleTerminologySparqlRequest {
	r.type_ = &type_
	return r
}

// The search parameter to sort results by
func (r ApiSearchSingleTerminologySparqlRequest) Sort(sort string) ApiSearchSingleTerminologySparqlRequest {
	r.sort = &sort
	return r
}

// Sort ascending (if true) or descending (if false)
func (r ApiSearchSingleTerminologySparqlRequest) Ascending(ascending bool) ApiSearchSingleTerminologySparqlRequest {
	r.ascending = &ascending
	return r
}

// Start index of the search results
func (r ApiSearchSingleTerminologySparqlRequest) FromRecord(fromRecord int32) ApiSearchSingleTerminologySparqlRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiSearchSingleTerminologySparqlRequest) PageSize(pageSize int32) ApiSearchSingleTerminologySparqlRequest {
	r.pageSize = &pageSize
	return r
}

// Comma-separated list of concept status values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/conceptStatuses&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) ConceptStatus(conceptStatus string) ApiSearchSingleTerminologySparqlRequest {
	r.conceptStatus = &conceptStatus
	return r
}

// Comma-separated list of properties to restrict search results by (see also &lt;i&gt;value&lt;/i&gt;). e.g.&lt;ul&gt;&lt;li&gt;&#39;P106,P322&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&#39;COLOR,SHAPE&#39; for &lt;i&gt;terminology&#x3D;ncim&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus properties&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/properties&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus properties&lt;/a&gt;.&lt;/p&gt; The properties can be specified as code or name. NOTE: This feature works with &lt;i&gt;value&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching the &lt;i&gt;value&lt;/i&gt; parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchSingleTerminologySparqlRequest) Property(property string) ApiSearchSingleTerminologySparqlRequest {
	r.property = &property
	return r
}

// A property value to restrict search results by.  NOTE: This feature works with &lt;i&gt;property&lt;/i&gt; to find concepts having one of the specified properties with an exact value matching this parameter.  Using a &lt;i&gt;term&lt;/i&gt; will further restrict results to those also matching the term.
func (r ApiSearchSingleTerminologySparqlRequest) Value(value string) ApiSearchSingleTerminologySparqlRequest {
	r.value = &value
	return r
}

// Comma-separated list of definition sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/definitionSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) DefinitionSource(definitionSource string) ApiSearchSingleTerminologySparqlRequest {
	r.definitionSource = &definitionSource
	return r
}

// Comma-separated list of definition types to restrict search results by, e.g. &#39;DEFINITION,ALT_DEFINITION&#39; for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/definitionTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) DefinitionType(definitionType string) ApiSearchSingleTerminologySparqlRequest {
	r.definitionType = &definitionType
	return r
}

// Comma-separated list of synonym sources to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/synonymSources&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) SynonymSource(synonymSource string) ApiSearchSingleTerminologySparqlRequest {
	r.synonymSource = &synonymSource
	return r
}

// Comma-separated list of synonym types to restrict search results by, e.g. &#39;FULL_SYN&#39;. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/synonymTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) SynonymType(synonymType string) ApiSearchSingleTerminologySparqlRequest {
	r.synonymType = &synonymType
	return r
}

// Comma-separated list of synonym term type values to restrict search results by. &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncit/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Thesaurus values&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;a href&#x3D;&#39;/api/v1/metadata/ncim/termTypes&#39; target&#x3D;&#39;_blank&#39;&gt;Click here for a list of NCI Metathesaurus values&lt;/a&gt;.&lt;/p&gt;
func (r ApiSearchSingleTerminologySparqlRequest) SynonymTermType(synonymTermType string) ApiSearchSingleTerminologySparqlRequest {
	r.synonymTermType = &synonymTermType
	return r
}

// Comma-separated list of subsets to restrict search results by, e.g. &#39;C157225&#39;. The value &#39;*&#39; can also be used to return results that participate in at least one subset. This parameter is only meaningful for &lt;i&gt;terminology&#x3D;ncit&lt;/i&gt;
func (r ApiSearchSingleTerminologySparqlRequest) Subset(subset string) ApiSearchSingleTerminologySparqlRequest {
	r.subset = &subset
	return r
}

func (r ApiSearchSingleTerminologySparqlRequest) Execute() (*ConceptResultList, *http.Response, error) {
	return r.ApiService.SearchSingleTerminologySparqlExecute(r)
}

/*
SearchSingleTerminologySparql Get concept search results for a specified terminology

Use cases for search range from very simple term searches, use of paging parameters, additional filters, searches properties, roles, and associations, and so on.  To further explore the range of search options, take a look at the <a href='https://github.com/NCIEVS/evsrestapi-client-SDK' target='_blank'>Github client SDK library created for the NCI EVS Rest API</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Single terminology to search, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @return ApiSearchSingleTerminologySparqlRequest
*/
func (a *SearchEndpointAPIService) SearchSingleTerminologySparql(ctx context.Context, terminology string) ApiSearchSingleTerminologySparqlRequest {
	return ApiSearchSingleTerminologySparqlRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ConceptResultList
func (a *SearchEndpointAPIService) SearchSingleTerminologySparqlExecute(r ApiSearchSingleTerminologySparqlRequest) (*ConceptResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConceptResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchEndpointAPIService.SearchSingleTerminologySparql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.term != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.conceptStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conceptStatus", r.conceptStatus, "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	if r.definitionSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionSource", r.definitionSource, "")
	}
	if r.definitionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "definitionType", r.definitionType, "")
	}
	if r.synonymSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymSource", r.synonymSource, "")
	}
	if r.synonymType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymType", r.synonymType, "")
	}
	if r.synonymTermType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "synonymTermType", r.synonymTermType, "")
	}
	if r.subset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subset", r.subset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

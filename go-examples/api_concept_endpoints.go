/*
NCI EVS Rest API

Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>

API version: 1.7.2.RELEASE
Contact: NCIAppSupport@nih.gov
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConceptEndpointsAPIService ConceptEndpointsAPI service
type ConceptEndpointsAPIService service

type ApiGetAssociationEntriesRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	codeOrLabel string
	fromRecord *int32
	pageSize *int32
	xEVSRESTAPILicenseKey *string
}

// Start index of the search results
func (r ApiGetAssociationEntriesRequest) FromRecord(fromRecord int32) ApiGetAssociationEntriesRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetAssociationEntriesRequest) PageSize(pageSize int32) ApiGetAssociationEntriesRequest {
	r.pageSize = &pageSize
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetAssociationEntriesRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetAssociationEntriesRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetAssociationEntriesRequest) Execute() (*AssociationEntryResultList, *http.Response, error) {
	return r.ApiService.GetAssociationEntriesExecute(r)
}

/*
GetAssociationEntries Get the association entries for the specified terminology and code. Associations used to define subset membership are not resolved by this call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param codeOrLabel Code/label in the specified terminology, e.g. 'A5' or 'Has_Salt_Form' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetAssociationEntriesRequest
*/
func (a *ConceptEndpointsAPIService) GetAssociationEntries(ctx context.Context, terminology string, codeOrLabel string) ApiGetAssociationEntriesRequest {
	return ApiGetAssociationEntriesRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		codeOrLabel: codeOrLabel,
	}
}

// Execute executes the request
//  @return AssociationEntryResultList
func (a *ConceptEndpointsAPIService) GetAssociationEntriesExecute(r ApiGetAssociationEntriesRequest) (*AssociationEntryResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssociationEntryResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetAssociationEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/associations/{codeOrLabel}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"codeOrLabel"+"}", url.PathEscape(parameterValueToString(r.codeOrLabel, "codeOrLabel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssociations1Request struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetAssociations1Request) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetAssociations1Request {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetAssociations1Request) Execute() ([]Association, *http.Response, error) {
	return r.ApiService.GetAssociations1Execute(r)
}

/*
GetAssociations1 Get the associations for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @param code Code in the specified terminology, e.g. <ul><li>'C3224' for <i>ncit</i></li><li>'C0025202' for <i>ncim</i></li></ul>
 @return ApiGetAssociations1Request
*/
func (a *ConceptEndpointsAPIService) GetAssociations1(ctx context.Context, terminology string, code string) ApiGetAssociations1Request {
	return ApiGetAssociations1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Association
func (a *ConceptEndpointsAPIService) GetAssociations1Execute(r ApiGetAssociations1Request) ([]Association, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Association
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetAssociations1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/associations"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChildrenRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetChildrenRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetChildrenRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetChildrenRequest) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetChildrenExecute(r)
}

/*
GetChildren Get child concepts for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @param code Code in the specified terminology, e.g. <ul><li>'C3224' for <i>ncit</i></li><li>'C0025202' for <i>ncim</i></li></ul>
 @return ApiGetChildrenRequest
*/
func (a *ConceptEndpointsAPIService) GetChildren(ctx context.Context, terminology string, code string) ApiGetChildrenRequest {
	return ApiGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetChildrenExecute(r ApiGetChildrenRequest) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConceptRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	limit *int32
	include *string
	xEVSRESTAPILicenseKey *string
}

// If set to an integer (between &lt;i&gt;1&lt;/i&gt; and &lt;i&gt;100&lt;/i&gt;), elements of the concept should be limited to that specified number of entries. Thus a user interface can quickly retrieve initial data for a concept (even with &lt;i&gt;include&#x3D;full&lt;/i&gt;) and then call back for more data. An extra placeholder entry with just a &lt;i&gt;ct&lt;/i&gt; field will be included to indicate the total count.
func (r ApiGetConceptRequest) Limit(limit int32) ApiGetConceptRequest {
	r.limit = &limit
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetConceptRequest) Include(include string) ApiGetConceptRequest {
	r.include = &include
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetConceptRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetConceptRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetConceptRequest) Execute() (*Concept, *http.Response, error) {
	return r.ApiService.GetConceptExecute(r)
}

/*
GetConcept Get the concept for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @param code Code in the specified terminology, e.g.<ul><li>'C3224' for <i>ncit</i></li><li>'C0025202' for <i>ncim</i></li></ul>
 @return ApiGetConceptRequest
*/
func (a *ConceptEndpointsAPIService) GetConcept(ctx context.Context, terminology string, code string) ApiGetConceptRequest {
	return ApiGetConceptRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Concept
func (a *ConceptEndpointsAPIService) GetConceptExecute(r ApiGetConceptRequest) (*Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetConcept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConceptsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	list *string
	include *string
	xEVSRESTAPILicenseKey *string
}

// List (comma-separated) of codes to return concepts for, e.g.&lt;ul&gt;&lt;li&gt;&#39;C2291,C3224&#39; for &lt;i&gt;ncit&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&#39;C0010137,C0025202&#39; for &lt;i&gt;ncim&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
func (r ApiGetConceptsRequest) List(list string) ApiGetConceptsRequest {
	r.list = &list
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetConceptsRequest) Include(include string) ApiGetConceptsRequest {
	r.include = &include
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetConceptsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetConceptsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetConceptsRequest) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetConceptsExecute(r)
}

/*
GetConcepts Get concepts specified by list parameter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @return ApiGetConceptsRequest
*/
func (a *ConceptEndpointsAPIService) GetConcepts(ctx context.Context, terminology string) ApiGetConceptsRequest {
	return ApiGetConceptsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetConceptsExecute(r ApiGetConceptsRequest) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetConcepts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.list == nil {
		return localVarReturnValue, nil, reportError("list is required and must be specified")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "list", r.list, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDescendantsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	fromRecord *int32
	pageSize *int32
	maxLevel *int32
	xEVSRESTAPILicenseKey *string
}

// Start index of the search results
func (r ApiGetDescendantsRequest) FromRecord(fromRecord int32) ApiGetDescendantsRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetDescendantsRequest) PageSize(pageSize int32) ApiGetDescendantsRequest {
	r.pageSize = &pageSize
	return r
}

// Max level of results to return
func (r ApiGetDescendantsRequest) MaxLevel(maxLevel int32) ApiGetDescendantsRequest {
	r.maxLevel = &maxLevel
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetDescendantsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetDescendantsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetDescendantsRequest) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetDescendantsExecute(r)
}

/*
GetDescendants Get descendant concepts for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit''
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetDescendantsRequest
*/
func (a *ConceptEndpointsAPIService) GetDescendants(ctx context.Context, terminology string, code string) ApiGetDescendantsRequest {
	return ApiGetDescendantsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetDescendantsExecute(r ApiGetDescendantsRequest) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetDescendants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/descendants"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.maxLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxLevel", r.maxLevel, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDisjointWithRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetDisjointWithRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetDisjointWithRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetDisjointWithRequest) Execute() ([]DisjointWith, *http.Response, error) {
	return r.ApiService.GetDisjointWithExecute(r)
}

/*
GetDisjointWith Get \"disjoint with\" info for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3910' for <i>ncit</i>.  This call is only meaningful for <i>ncit</i>.
 @return ApiGetDisjointWithRequest
*/
func (a *ConceptEndpointsAPIService) GetDisjointWith(ctx context.Context, terminology string, code string) ApiGetDisjointWithRequest {
	return ApiGetDisjointWithRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []DisjointWith
func (a *ConceptEndpointsAPIService) GetDisjointWithExecute(r ApiGetDisjointWithRequest) ([]DisjointWith, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DisjointWith
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetDisjointWith")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/disjointWith"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoryRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetHistoryRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetHistoryRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetHistoryRequest) Execute() (*Concept, *http.Response, error) {
	return r.ApiService.GetHistoryExecute(r)
}

/*
GetHistory Get history for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i> and <i>ncim</i>.
 @return ApiGetHistoryRequest
*/
func (a *ConceptEndpointsAPIService) GetHistory(ctx context.Context, terminology string, code string) ApiGetHistoryRequest {
	return ApiGetHistoryRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Concept
func (a *ConceptEndpointsAPIService) GetHistoryExecute(r ApiGetHistoryRequest) (*Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInverseAssociationsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetInverseAssociationsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetInverseAssociationsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetInverseAssociationsRequest) Execute() ([]Association, *http.Response, error) {
	return r.ApiService.GetInverseAssociationsExecute(r)
}

/*
GetInverseAssociations Get inverse associations for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @param code Code in the specified terminology, e.g.<ul><li>'C3224' for <i>ncit</i></li><li>'C0025202' for <i>ncim</i></li></ul>
 @return ApiGetInverseAssociationsRequest
*/
func (a *ConceptEndpointsAPIService) GetInverseAssociations(ctx context.Context, terminology string, code string) ApiGetInverseAssociationsRequest {
	return ApiGetInverseAssociationsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Association
func (a *ConceptEndpointsAPIService) GetInverseAssociationsExecute(r ApiGetInverseAssociationsRequest) ([]Association, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Association
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetInverseAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/inverseAssociations"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInverseRolesRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetInverseRolesRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetInverseRolesRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetInverseRolesRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.GetInverseRolesExecute(r)
}

/*
GetInverseRoles Get inverse roles for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>.  This call is only meaningful for <i>ncit</i>.
 @return ApiGetInverseRolesRequest
*/
func (a *ConceptEndpointsAPIService) GetInverseRoles(ctx context.Context, terminology string, code string) ApiGetInverseRolesRequest {
	return ApiGetInverseRolesRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Role
func (a *ConceptEndpointsAPIService) GetInverseRolesExecute(r ApiGetInverseRolesRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetInverseRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/inverseRoles"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMapsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetMapsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetMapsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetMapsRequest) Execute() ([]ConceptMap, *http.Response, error) {
	return r.ApiService.GetMapsExecute(r)
}

/*
GetMaps Get maps for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetMapsRequest
*/
func (a *ConceptEndpointsAPIService) GetMaps(ctx context.Context, terminology string, code string) ApiGetMapsRequest {
	return ApiGetMapsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []ConceptMap
func (a *ConceptEndpointsAPIService) GetMapsExecute(r ApiGetMapsRequest) ([]ConceptMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConceptMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetMaps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/maps"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParentsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetParentsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetParentsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetParentsRequest) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetParentsExecute(r)
}

/*
GetParents Get parent concepts for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit' or 'ncim' (<a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/TERMINOLOGIES.md\">See here for complete list</a>)
 @param code Code in the specified terminology, e.g. <ul><li>'C3224' for <i>ncit</i></li><li>'C0025202' for <i>ncim</i></li></ul>
 @return ApiGetParentsRequest
*/
func (a *ConceptEndpointsAPIService) GetParents(ctx context.Context, terminology string, code string) ApiGetParentsRequest {
	return ApiGetParentsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetParentsExecute(r ApiGetParentsRequest) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetParents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/parents"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPathsFromRootRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	include *string
	fromRecord *int32
	pageSize *int32
	xEVSRESTAPILicenseKey *string
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;. For this call, it is recommended to avoid using this parameter unless you need it for a specific use case.  Any value other than &#39;minimal&#39; may produce very large payload results. 
func (r ApiGetPathsFromRootRequest) Include(include string) ApiGetPathsFromRootRequest {
	r.include = &include
	return r
}

// Start index of the search results
func (r ApiGetPathsFromRootRequest) FromRecord(fromRecord int32) ApiGetPathsFromRootRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetPathsFromRootRequest) PageSize(pageSize int32) ApiGetPathsFromRootRequest {
	r.pageSize = &pageSize
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetPathsFromRootRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetPathsFromRootRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetPathsFromRootRequest) Execute() ([][]Concept, *http.Response, error) {
	return r.ApiService.GetPathsFromRootExecute(r)
}

/*
GetPathsFromRoot Get paths from the hierarchy root to the specified concept.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetPathsFromRootRequest
*/
func (a *ConceptEndpointsAPIService) GetPathsFromRoot(ctx context.Context, terminology string, code string) ApiGetPathsFromRootRequest {
	return ApiGetPathsFromRootRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return [][]Concept
func (a *ConceptEndpointsAPIService) GetPathsFromRootExecute(r ApiGetPathsFromRootRequest) ([][]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetPathsFromRoot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/pathsFromRoot"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPathsToAncestorRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	ancestorCode string
	include *string
	fromRecord *int32
	pageSize *int32
	xEVSRESTAPILicenseKey *string
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;. For this call, it is recommended to avoid using this parameter unless you need it for a specific use case.  Any value other than &#39;minimal&#39; may produce very large payload results. 
func (r ApiGetPathsToAncestorRequest) Include(include string) ApiGetPathsToAncestorRequest {
	r.include = &include
	return r
}

// Start index of the search results
func (r ApiGetPathsToAncestorRequest) FromRecord(fromRecord int32) ApiGetPathsToAncestorRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetPathsToAncestorRequest) PageSize(pageSize int32) ApiGetPathsToAncestorRequest {
	r.pageSize = &pageSize
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetPathsToAncestorRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetPathsToAncestorRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetPathsToAncestorRequest) Execute() ([][]Concept, *http.Response, error) {
	return r.ApiService.GetPathsToAncestorExecute(r)
}

/*
GetPathsToAncestor Get paths from the specified code to the specified ancestor code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @param ancestorCode Ancestor code of the other specified code, e.g. 'C2991' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetPathsToAncestorRequest
*/
func (a *ConceptEndpointsAPIService) GetPathsToAncestor(ctx context.Context, terminology string, code string, ancestorCode string) ApiGetPathsToAncestorRequest {
	return ApiGetPathsToAncestorRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
		ancestorCode: ancestorCode,
	}
}

// Execute executes the request
//  @return [][]Concept
func (a *ConceptEndpointsAPIService) GetPathsToAncestorExecute(r ApiGetPathsToAncestorRequest) ([][]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetPathsToAncestor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/pathsToAncestor/{ancestorCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ancestorCode"+"}", url.PathEscape(parameterValueToString(r.ancestorCode, "ancestorCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPathsToRootRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	include *string
	fromRecord *int32
	pageSize *int32
	xEVSRESTAPILicenseKey *string
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;. For this call, it is recommended to avoid using this parameter unless you need it for a specific use case.  Any value other than &#39;minimal&#39; may produce very large payload results. 
func (r ApiGetPathsToRootRequest) Include(include string) ApiGetPathsToRootRequest {
	r.include = &include
	return r
}

// Start index of the search results
func (r ApiGetPathsToRootRequest) FromRecord(fromRecord int32) ApiGetPathsToRootRequest {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetPathsToRootRequest) PageSize(pageSize int32) ApiGetPathsToRootRequest {
	r.pageSize = &pageSize
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetPathsToRootRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetPathsToRootRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetPathsToRootRequest) Execute() ([][]Concept, *http.Response, error) {
	return r.ApiService.GetPathsToRootExecute(r)
}

/*
GetPathsToRoot Get paths to the hierarchy root from the specified code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetPathsToRootRequest
*/
func (a *ConceptEndpointsAPIService) GetPathsToRoot(ctx context.Context, terminology string, code string) ApiGetPathsToRootRequest {
	return ApiGetPathsToRootRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return [][]Concept
func (a *ConceptEndpointsAPIService) GetPathsToRootExecute(r ApiGetPathsToRootRequest) ([][]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetPathsToRoot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/pathsToRoot"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoles1Request struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	xEVSRESTAPILicenseKey *string
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetRoles1Request) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetRoles1Request {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetRoles1Request) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.GetRoles1Execute(r)
}

/*
GetRoles1 Get roles for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetRoles1Request
*/
func (a *ConceptEndpointsAPIService) GetRoles1(ctx context.Context, terminology string, code string) ApiGetRoles1Request {
	return ApiGetRoles1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Role
func (a *ConceptEndpointsAPIService) GetRoles1Execute(r ApiGetRoles1Request) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetRoles1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRootsRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	include *string
	xEVSRESTAPILicenseKey *string
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetRootsRequest) Include(include string) ApiGetRootsRequest {
	r.include = &include
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetRootsRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetRootsRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetRootsRequest) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetRootsExecute(r)
}

/*
GetRoots Get root concepts for the specified terminology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'.  This call is only meaningful for <i>ncit</i>.
 @return ApiGetRootsRequest
*/
func (a *ConceptEndpointsAPIService) GetRoots(ctx context.Context, terminology string) ApiGetRootsRequest {
	return ApiGetRootsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetRootsExecute(r ApiGetRootsRequest) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetRoots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/roots"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubsetMembers1Request struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	fromRecord *int32
	pageSize *int32
	include *string
	xEVSRESTAPILicenseKey *string
}

// Start index of the search results
func (r ApiGetSubsetMembers1Request) FromRecord(fromRecord int32) ApiGetSubsetMembers1Request {
	r.fromRecord = &fromRecord
	return r
}

// Max number of results to return
func (r ApiGetSubsetMembers1Request) PageSize(pageSize int32) ApiGetSubsetMembers1Request {
	r.pageSize = &pageSize
	return r
}

// Indicator of how much data to return. Comma-separated list of any of the following values: minimal, summary, full, associations, children, definitions, disjointWith, history, inverseAssociations, inverseRoles, maps, parents, properties, roles, synonyms. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/INCLUDE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetSubsetMembers1Request) Include(include string) ApiGetSubsetMembers1Request {
	r.include = &include
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetSubsetMembers1Request) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetSubsetMembers1Request {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetSubsetMembers1Request) Execute() ([]Concept, *http.Response, error) {
	return r.ApiService.GetSubsetMembers1Execute(r)
}

/*
GetSubsetMembers1 Get subset members for the specified terminology and code.

This endpoint will be deprecated in v2 in favor of a top level subset member endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code for a subset concept in the specified terminology, e.g. 'C157225' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetSubsetMembers1Request
*/
func (a *ConceptEndpointsAPIService) GetSubsetMembers1(ctx context.Context, terminology string, code string) ApiGetSubsetMembers1Request {
	return ApiGetSubsetMembers1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []Concept
func (a *ConceptEndpointsAPIService) GetSubsetMembers1Execute(r ApiGetSubsetMembers1Request) ([]Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetSubsetMembers1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/subsetMembers/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRecord != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRecord", r.fromRecord, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubtreeRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	limit *int32
	xEVSRESTAPILicenseKey *string
}

// If set to an integer (between &lt;i&gt;1&lt;/i&gt; and &lt;i&gt;100&lt;/i&gt;), subtrees and siblings at each level will be limited to the specified number of entries. Thus a user interface can quickly retrieve initial data for a subtree and then call back for more data. An extra placeholder entry with just a &lt;i&gt;ct&lt;/i&gt; field will be included to indicate the total count.
func (r ApiGetSubtreeRequest) Limit(limit int32) ApiGetSubtreeRequest {
	r.limit = &limit
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetSubtreeRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetSubtreeRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetSubtreeRequest) Execute() ([]HierarchyNode, *http.Response, error) {
	return r.ApiService.GetSubtreeExecute(r)
}

/*
GetSubtree Get the entire subtree from the root node to the specified code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetSubtreeRequest
*/
func (a *ConceptEndpointsAPIService) GetSubtree(ctx context.Context, terminology string, code string) ApiGetSubtreeRequest {
	return ApiGetSubtreeRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []HierarchyNode
func (a *ConceptEndpointsAPIService) GetSubtreeExecute(r ApiGetSubtreeRequest) ([]HierarchyNode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HierarchyNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetSubtree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/subtree"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubtreeChildrenRequest struct {
	ctx context.Context
	ApiService *ConceptEndpointsAPIService
	terminology string
	code string
	limit *int32
	xEVSRESTAPILicenseKey *string
}

// If set to an integer (between &lt;i&gt;1&lt;/i&gt; and &lt;i&gt;100&lt;/i&gt;), children will be limited to the specified number of entries. Thus a user interface can quickly retrieve initial data for a subtree and then call back for more data. An extra placeholder entry with just a &lt;i&gt;ct&lt;/i&gt; field will be included to indicate the total count.
func (r ApiGetSubtreeChildrenRequest) Limit(limit int32) ApiGetSubtreeChildrenRequest {
	r.limit = &limit
	return r
}

// Required license information for restricted terminologies. &lt;a href&#x3D;&#39;https://github.com/NCIEVS/evsrestapi-client-SDK/blob/master/doc/LICENSE.md&#39; target&#x3D;&#39;_blank&#39;&gt;See here for detailed information&lt;/a&gt;.
func (r ApiGetSubtreeChildrenRequest) XEVSRESTAPILicenseKey(xEVSRESTAPILicenseKey string) ApiGetSubtreeChildrenRequest {
	r.xEVSRESTAPILicenseKey = &xEVSRESTAPILicenseKey
	return r
}

func (r ApiGetSubtreeChildrenRequest) Execute() ([]HierarchyNode, *http.Response, error) {
	return r.ApiService.GetSubtreeChildrenExecute(r)
}

/*
GetSubtreeChildren Get the entire subtree from the root node to the specified code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology Terminology, e.g. 'ncit'
 @param code Code in the specified terminology, e.g. 'C3224' for <i>ncit</i>. This call is only meaningful for <i>ncit</i>.
 @return ApiGetSubtreeChildrenRequest
*/
func (a *ConceptEndpointsAPIService) GetSubtreeChildren(ctx context.Context, terminology string, code string) ApiGetSubtreeChildrenRequest {
	return ApiGetSubtreeChildrenRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return []HierarchyNode
func (a *ConceptEndpointsAPIService) GetSubtreeChildrenExecute(r ApiGetSubtreeChildrenRequest) ([]HierarchyNode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HierarchyNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConceptEndpointsAPIService.GetSubtreeChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/concept/{terminology}/{code}/subtree/children"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEVSRESTAPILicenseKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-EVSRESTAPI-License-Key", r.xEVSRESTAPILicenseKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

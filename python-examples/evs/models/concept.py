# coding: utf-8

"""
    NCI EVS Rest API

    Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to
    interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github
    evsrestapi-client-SDK project.</a>

    The version of the OpenAPI document: 1.7.2.RELEASE
    Contact: NCIAppSupport@nih.gov
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from evs.models.association import Association
from evs.models.concept_map import ConceptMap
from evs.models.definition import Definition
from evs.models.disjoint_with import DisjointWith
from evs.models.history import History
from evs.models.model_property import ModelProperty
from evs.models.paths import Paths
from evs.models.qualifier import Qualifier
from evs.models.role import Role
from evs.models.synonym import Synonym
from typing import Optional, Set
from typing_extensions import Self


class Concept(BaseModel):
    """
    Represents a concept in a terminology
    """  # noqa: E501
    uri: Optional[StrictStr] = Field(default=None, description="URI for this element in an rdf-based source file")
    ct: Optional[StrictInt] = Field(default=None,
                                    description="Used to indicate the total amount of data in cases where a limit is "
                                                "being applied")
    code: Optional[StrictStr] = Field(default=None, description="Code (unique identifier) for this meaning")
    name: Optional[StrictStr] = Field(default=None, description="Preferred name for the code")
    terminology: Optional[StrictStr] = Field(default=None, description="Terminology abbreviation, e.g. 'nci'")
    version: Optional[StrictStr] = Field(default=None, description="Terminology version, e.g. '23.11d'")
    level: Optional[StrictInt] = Field(default=None,
                                       description="Level of depth in a hierarchy (when this object is used to "
                                                   "represent an element in a path)")
    highlight: Optional[StrictStr] = Field(default=None,
                                           description="Used by search calls to provide information for highlighting "
                                                       "a view of results")
    subset_link: Optional[StrictStr] = Field(default=None,
                                             description="Link to download data for a subset, used when the concept "
                                                         "represents subset metadata",
                                             alias="subsetLink")
    mapset_link: Optional[StrictStr] = Field(default=None, description="Metadata for downloading a mapset",
                                             alias="mapsetLink")
    concept_status: Optional[StrictStr] = Field(default=None,
                                                description="Status value for the concept, e.g. Retired_Concept",
                                                alias="conceptStatus")
    source: Optional[StrictStr] = Field(default=None, description="Associations from this concept to other ones")
    leaf: Optional[StrictBool] = Field(default=None, description="Indicates whether concept is a leaf node")
    active: Optional[StrictBool] = Field(default=None, description="Indicates whether the concept is active")
    synonyms: Optional[List[Synonym]] = Field(default=None,
                                              description="Synonyms, or all of the names for this concept, "
                                                          "including the preferred name")
    definitions: Optional[List[Definition]] = Field(default=None, description="Text definitions")
    properties: Optional[List[ModelProperty]] = Field(default=None, description="Key/value properties")
    children: Optional[List[Concept]] = Field(default=None, description="Child concepts in the hierarchy")
    parents: Optional[List[Concept]] = Field(default=None, description="Parent concepts in the hierarchy")
    descendants: Optional[List[Concept]] = Field(default=None, description="Descendant concepts in the hierarchy")
    qualifiers: Optional[List[Qualifier]] = Field(default=None,
                                                  description="Qualifiers for use when a concept is used as a "
                                                              "parent/child - to indicate RELA for NCIm-derived "
                                                              "content")
    associations: Optional[List[Association]] = Field(default=None,
                                                      description="Associations from this concept to other ones")
    inverse_associations: Optional[List[Association]] = Field(default=None,
                                                              description="Associations to this concept from other "
                                                                          "ones",
                                                              alias="inverseAssociations")
    roles: Optional[List[Role]] = Field(default=None, description="Roles from this concept to other ones")
    disjoint_with: Optional[List[DisjointWith]] = Field(default=None,
                                                        description="Assertions of disjointness with respect to other"
                                                                    " concepts",
                                                        alias="disjointWith")
    inverse_roles: Optional[List[Role]] = Field(default=None, description="Roles to this concept from other ones",
                                                alias="inverseRoles")
    history: Optional[List[History]] = Field(default=None, description="History records")
    maps: Optional[List[ConceptMap]] = Field(default=None,
                                             description="Maps from this concept to concepts in other terminologies")
    paths: Optional[Paths] = None
    __properties: ClassVar[List[str]] = ["uri", "ct", "code", "name", "terminology", "version", "level", "highlight",
                                         "subsetLink", "mapsetLink", "conceptStatus", "source", "leaf", "active",
                                         "synonyms", "definitions", "properties", "children", "parents", "descendants",
                                         "qualifiers", "associations", "inverseAssociations", "roles", "disjointWith",
                                         "inverseRoles", "history", "maps", "paths"]
    
    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )
    
    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))
    
    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())
    
    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Concept from a JSON string"""
        return cls.from_dict(json.loads(json_str))
    
    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])
        
        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in synonyms (list)
        _items = []
        if self.synonyms:
            for _item in self.synonyms:
                if _item:
                    _items.append(_item.to_dict())
            _dict['synonyms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in definitions (list)
        _items = []
        if self.definitions:
            for _item in self.definitions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['definitions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in properties (list)
        _items = []
        if self.properties:
            for _item in self.properties:
                if _item:
                    _items.append(_item.to_dict())
            _dict['properties'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in children (list)
        _items = []
        if self.children:
            for _item in self.children:
                if _item:
                    _items.append(_item.to_dict())
            _dict['children'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in parents (list)
        _items = []
        if self.parents:
            for _item in self.parents:
                if _item:
                    _items.append(_item.to_dict())
            _dict['parents'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in descendants (list)
        _items = []
        if self.descendants:
            for _item in self.descendants:
                if _item:
                    _items.append(_item.to_dict())
            _dict['descendants'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in qualifiers (list)
        _items = []
        if self.qualifiers:
            for _item in self.qualifiers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['qualifiers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in associations (list)
        _items = []
        if self.associations:
            for _item in self.associations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['associations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inverse_associations (list)
        _items = []
        if self.inverse_associations:
            for _item in self.inverse_associations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['inverseAssociations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in roles (list)
        _items = []
        if self.roles:
            for _item in self.roles:
                if _item:
                    _items.append(_item.to_dict())
            _dict['roles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disjoint_with (list)
        _items = []
        if self.disjoint_with:
            for _item in self.disjoint_with:
                if _item:
                    _items.append(_item.to_dict())
            _dict['disjointWith'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inverse_roles (list)
        _items = []
        if self.inverse_roles:
            for _item in self.inverse_roles:
                if _item:
                    _items.append(_item.to_dict())
            _dict['inverseRoles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in history (list)
        _items = []
        if self.history:
            for _item in self.history:
                if _item:
                    _items.append(_item.to_dict())
            _dict['history'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in maps (list)
        _items = []
        if self.maps:
            for _item in self.maps:
                if _item:
                    _items.append(_item.to_dict())
            _dict['maps'] = _items
        # override the default output from pydantic by calling `to_dict()` of paths
        if self.paths:
            _dict['paths'] = self.paths.to_dict()
        return _dict
    
    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Concept from a dict"""
        if obj is None:
            return None
        
        if not isinstance(obj, dict):
            return cls.model_validate(obj)
        
        _obj = cls.model_validate({
            "uri": obj.get("uri"),
            "ct": obj.get("ct"),
            "code": obj.get("code"),
            "name": obj.get("name"),
            "terminology": obj.get("terminology"),
            "version": obj.get("version"),
            "level": obj.get("level"),
            "highlight": obj.get("highlight"),
            "subsetLink": obj.get("subsetLink"),
            "mapsetLink": obj.get("mapsetLink"),
            "conceptStatus": obj.get("conceptStatus"),
            "source": obj.get("source"),
            "leaf": obj.get("leaf"),
            "active": obj.get("active"),
            "synonyms": [Synonym.from_dict(_item) for _item in obj["synonyms"]] if obj.get(
                "synonyms") is not None else None,
            "definitions": [Definition.from_dict(_item) for _item in obj["definitions"]] if obj.get(
                "definitions") is not None else None,
            "properties": [ModelProperty.from_dict(_item) for _item in obj["properties"]] if obj.get(
                "properties") is not None else None,
            "children": [Concept.from_dict(_item) for _item in obj["children"]] if obj.get(
                "children") is not None else None,
            "parents": [Concept.from_dict(_item) for _item in obj["parents"]] if obj.get(
                "parents") is not None else None,
            "descendants": [Concept.from_dict(_item) for _item in obj["descendants"]] if obj.get(
                "descendants") is not None else None,
            "qualifiers": [Qualifier.from_dict(_item) for _item in obj["qualifiers"]] if obj.get(
                "qualifiers") is not None else None,
            "associations": [Association.from_dict(_item) for _item in obj["associations"]] if obj.get(
                "associations") is not None else None,
            "inverseAssociations": [Association.from_dict(_item) for _item in obj["inverseAssociations"]] if obj.get(
                "inverseAssociations") is not None else None,
            "roles": [Role.from_dict(_item) for _item in obj["roles"]] if obj.get("roles") is not None else None,
            "disjointWith": [DisjointWith.from_dict(_item) for _item in obj["disjointWith"]] if obj.get(
                "disjointWith") is not None else None,
            "inverseRoles": [Role.from_dict(_item) for _item in obj["inverseRoles"]] if obj.get(
                "inverseRoles") is not None else None,
            "history": [History.from_dict(_item) for _item in obj["history"]] if obj.get(
                "history") is not None else None,
            "maps": [ConceptMap.from_dict(_item) for _item in obj["maps"]] if obj.get("maps") is not None else None,
            "paths": Paths.from_dict(obj["paths"]) if obj.get("paths") is not None else None
        })
        return _obj


# TODO: Rewrite to not use raise_errors
Concept.model_rebuild(raise_errors=False)

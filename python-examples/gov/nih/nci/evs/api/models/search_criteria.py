# coding: utf-8

"""
    NCI EVS Rest API

    Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>

    The version of the OpenAPI document: 1.7.2.RELEASE
    Contact: NCIAppSupport@nih.gov
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class SearchCriteria(BaseModel):
    """
    Criteria for a search or find operation
    """ # noqa: E501
    uri: Optional[StrictStr] = Field(default=None, description="URI for this element in an rdf-based source file")
    ct: Optional[StrictInt] = Field(default=None, description="Used to indicate the total amount of data in cases where a limit is being applied")
    term: Optional[StrictStr] = Field(default=None, description="Search term, e.g. 'heart', or 'C3224'")
    type: Optional[StrictStr] = Field(default=None, description="The match type, one of: contains, match, startsWith, phrase, AND, OR, fuzzy")
    include: Optional[StrictStr] = Field(default=None, description="Include parameter value, e.g. 'minimal', 'summary', 'synonyms,properties,children'")
    sort: Optional[StrictStr] = Field(default=None, description="Sort field")
    ascending: Optional[StrictBool] = Field(default=None, description="Indicates whether sort is ascending (true), descending (false), or not specified (null)")
    from_record: Optional[StrictInt] = Field(default=None, description="Start index of the search results", alias="fromRecord")
    page_size: Optional[StrictInt] = Field(default=None, description="Max number of results to return", alias="pageSize")
    concept_status: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of concept status values to restrict search results by", alias="conceptStatus")
    var_property: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of properties to restrict search results by", alias="property")
    value: Optional[StrictStr] = Field(default=None, description="A property value to restrict search results by")
    synonym_source: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of synonym sources to restrict search results by", alias="synonymSource")
    synonym_type: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of synonym types to restrict search results by", alias="synonymType")
    definition_source: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of definition sources to restrict search results by", alias="definitionSource")
    definition_type: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of definition types to restrict search results by", alias="definitionType")
    synonym_term_type: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of synonym term types to restrict search results by", alias="synonymTermType")
    subset: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of subsets to restrict search results by, e.g. 'C157225'")
    terminology: Optional[List[StrictStr]] = Field(default=None, description="Comma-separated list of terminologies to search")
    __properties: ClassVar[List[str]] = ["uri", "ct", "term", "type", "include", "sort", "ascending", "fromRecord", "pageSize", "conceptStatus", "property", "value", "synonymSource", "synonymType", "definitionSource", "definitionType", "synonymTermType", "subset", "terminology"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchCriteria from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchCriteria from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "uri": obj.get("uri"),
            "ct": obj.get("ct"),
            "term": obj.get("term"),
            "type": obj.get("type"),
            "include": obj.get("include"),
            "sort": obj.get("sort"),
            "ascending": obj.get("ascending"),
            "fromRecord": obj.get("fromRecord"),
            "pageSize": obj.get("pageSize"),
            "conceptStatus": obj.get("conceptStatus"),
            "property": obj.get("property"),
            "value": obj.get("value"),
            "synonymSource": obj.get("synonymSource"),
            "synonymType": obj.get("synonymType"),
            "definitionSource": obj.get("definitionSource"),
            "definitionType": obj.get("definitionType"),
            "synonymTermType": obj.get("synonymTermType"),
            "subset": obj.get("subset"),
            "terminology": obj.get("terminology")
        })
        return _obj



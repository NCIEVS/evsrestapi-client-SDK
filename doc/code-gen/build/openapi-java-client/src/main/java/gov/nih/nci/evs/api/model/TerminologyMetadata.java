/*
 * NCI EVS Rest API
 * Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>
 *
 * The version of the OpenAPI document: 1.7.2.RELEASE
 * Contact: NCIAppSupport@nih.gov
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package gov.nih.nci.evs.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import gov.nih.nci.evs.api.invoker.JSON;

/**
 * TerminologyMetadata
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-21T14:42:35.933348-08:00[America/Los_Angeles]")
public class TerminologyMetadata {
  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  private String uri;

  public static final String SERIALIZED_NAME_CT = "ct";
  @SerializedName(SERIALIZED_NAME_CT)
  private Integer ct;

  public static final String SERIALIZED_NAME_UI_LABEL = "uiLabel";
  @SerializedName(SERIALIZED_NAME_UI_LABEL)
  private String uiLabel;

  public static final String SERIALIZED_NAME_MAX_VERSIONS = "maxVersions";
  @SerializedName(SERIALIZED_NAME_MAX_VERSIONS)
  private Integer maxVersions;

  public static final String SERIALIZED_NAME_LOADER = "loader";
  @SerializedName(SERIALIZED_NAME_LOADER)
  private String loader;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_CONCEPT_STATUS = "conceptStatus";
  @SerializedName(SERIALIZED_NAME_CONCEPT_STATUS)
  private String conceptStatus;

  public static final String SERIALIZED_NAME_CONCEPT_STATUSES = "conceptStatuses";
  @SerializedName(SERIALIZED_NAME_CONCEPT_STATUSES)
  private List<String> conceptStatuses;

  public static final String SERIALIZED_NAME_RETIRED_STATUS_VALUE = "retiredStatusValue";
  @SerializedName(SERIALIZED_NAME_RETIRED_STATUS_VALUE)
  private String retiredStatusValue;

  public static final String SERIALIZED_NAME_PREFERRED_NAME = "preferredName";
  @SerializedName(SERIALIZED_NAME_PREFERRED_NAME)
  private String preferredName;

  public static final String SERIALIZED_NAME_RELATIONSHIP_TO_TARGET = "relationshipToTarget";
  @SerializedName(SERIALIZED_NAME_RELATIONSHIP_TO_TARGET)
  private String relationshipToTarget;

  public static final String SERIALIZED_NAME_SYNONYM = "synonym";
  @SerializedName(SERIALIZED_NAME_SYNONYM)
  private Set<String> synonym;

  public static final String SERIALIZED_NAME_SYNONYM_TERM_TYPE = "synonymTermType";
  @SerializedName(SERIALIZED_NAME_SYNONYM_TERM_TYPE)
  private String synonymTermType;

  public static final String SERIALIZED_NAME_SYNONYM_SOURCE = "synonymSource";
  @SerializedName(SERIALIZED_NAME_SYNONYM_SOURCE)
  private String synonymSource;

  public static final String SERIALIZED_NAME_SYNONYM_CODE = "synonymCode";
  @SerializedName(SERIALIZED_NAME_SYNONYM_CODE)
  private String synonymCode;

  public static final String SERIALIZED_NAME_SYNONYM_SUB_SOURCE = "synonymSubSource";
  @SerializedName(SERIALIZED_NAME_SYNONYM_SUB_SOURCE)
  private String synonymSubSource;

  public static final String SERIALIZED_NAME_DEFINITION = "definition";
  @SerializedName(SERIALIZED_NAME_DEFINITION)
  private Set<String> definition;

  public static final String SERIALIZED_NAME_DEFINITION_SOURCE = "definitionSource";
  @SerializedName(SERIALIZED_NAME_DEFINITION_SOURCE)
  private String definitionSource;

  public static final String SERIALIZED_NAME_MAP_RELATION = "mapRelation";
  @SerializedName(SERIALIZED_NAME_MAP_RELATION)
  private String mapRelation;

  public static final String SERIALIZED_NAME_MAP = "map";
  @SerializedName(SERIALIZED_NAME_MAP)
  private String map;

  public static final String SERIALIZED_NAME_MAP_TARGET = "mapTarget";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET)
  private String mapTarget;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERM_TYPE = "mapTargetTermType";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERM_TYPE)
  private String mapTargetTermType;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY = "mapTargetTerminology";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY)
  private String mapTargetTerminology;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY_VERSION = "mapTargetTerminologyVersion";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY_VERSION)
  private String mapTargetTerminologyVersion;

  public static final String SERIALIZED_NAME_SOURCES = "sources";
  @SerializedName(SERIALIZED_NAME_SOURCES)
  private Map<String, String> sources = new HashMap<>();

  public static final String SERIALIZED_NAME_DETAILS_COLUMNS = "detailsColumns";
  @SerializedName(SERIALIZED_NAME_DETAILS_COLUMNS)
  private Map<String, Boolean> detailsColumns = new HashMap<>();

  public static final String SERIALIZED_NAME_HIERARCHY = "hierarchy";
  @SerializedName(SERIALIZED_NAME_HIERARCHY)
  private Boolean hierarchy;

  public static final String SERIALIZED_NAME_HISTORY = "history";
  @SerializedName(SERIALIZED_NAME_HISTORY)
  private Boolean history;

  public static final String SERIALIZED_NAME_MAPSETS = "mapsets";
  @SerializedName(SERIALIZED_NAME_MAPSETS)
  private Boolean mapsets;

  public static final String SERIALIZED_NAME_SOURCE_CT = "sourceCt";
  @SerializedName(SERIALIZED_NAME_SOURCE_CT)
  private Integer sourceCt;

  public static final String SERIALIZED_NAME_DEFINITION_SOURCE_SET = "definitionSourceSet";
  @SerializedName(SERIALIZED_NAME_DEFINITION_SOURCE_SET)
  private Set<String> definitionSourceSet;

  public static final String SERIALIZED_NAME_SYNONYM_SOURCE_SET = "synonymSourceSet";
  @SerializedName(SERIALIZED_NAME_SYNONYM_SOURCE_SET)
  private Set<String> synonymSourceSet;

  public static final String SERIALIZED_NAME_TERM_TYPES = "termTypes";
  @SerializedName(SERIALIZED_NAME_TERM_TYPES)
  private Map<String, String> termTypes = new HashMap<>();

  public static final String SERIALIZED_NAME_SUBSET_PREFIX = "subsetPrefix";
  @SerializedName(SERIALIZED_NAME_SUBSET_PREFIX)
  private String subsetPrefix;

  public static final String SERIALIZED_NAME_SUBSET_LINK = "subsetLink";
  @SerializedName(SERIALIZED_NAME_SUBSET_LINK)
  private String subsetLink;

  public static final String SERIALIZED_NAME_SOURCES_TO_REMOVE = "sourcesToRemove";
  @SerializedName(SERIALIZED_NAME_SOURCES_TO_REMOVE)
  private Set<String> sourcesToRemove;

  public static final String SERIALIZED_NAME_SUBSET_MEMBER = "subsetMember";
  @SerializedName(SERIALIZED_NAME_SUBSET_MEMBER)
  private Set<String> subsetMember;

  public static final String SERIALIZED_NAME_UNPUBLISHED = "unpublished";
  @SerializedName(SERIALIZED_NAME_UNPUBLISHED)
  private Set<String> unpublished;

  public static final String SERIALIZED_NAME_MONTHLY_DB = "monthlyDb";
  @SerializedName(SERIALIZED_NAME_MONTHLY_DB)
  private String monthlyDb;

  public static final String SERIALIZED_NAME_SUBSET = "subset";
  @SerializedName(SERIALIZED_NAME_SUBSET)
  private Set<String> subset;

  public static final String SERIALIZED_NAME_LICENSE_TEXT = "licenseText";
  @SerializedName(SERIALIZED_NAME_LICENSE_TEXT)
  private String licenseText;

  public static final String SERIALIZED_NAME_META_CONCEPT_FIELD = "metaConceptField";
  @SerializedName(SERIALIZED_NAME_META_CONCEPT_FIELD)
  private String metaConceptField;

  public static final String SERIALIZED_NAME_PREFERRED_TERM_TYPES = "preferredTermTypes";
  @SerializedName(SERIALIZED_NAME_PREFERRED_TERM_TYPES)
  private List<String> preferredTermTypes;

  public static final String SERIALIZED_NAME_CODE_LABEL = "codeLabel";
  @SerializedName(SERIALIZED_NAME_CODE_LABEL)
  private String codeLabel;

  public static final String SERIALIZED_NAME_WELCOME_TEXT = "welcomeText";
  @SerializedName(SERIALIZED_NAME_WELCOME_TEXT)
  private String welcomeText;

  public static final String SERIALIZED_NAME_SYNONYM_TERM_GROUP = "synonymTermGroup";
  @SerializedName(SERIALIZED_NAME_SYNONYM_TERM_GROUP)
  private String synonymTermGroup;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERM_GROUP = "mapTargetTermGroup";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERM_GROUP)
  private String mapTargetTermGroup;

  public static final String SERIALIZED_NAME_TERM_GROUPS = "termGroups";
  @SerializedName(SERIALIZED_NAME_TERM_GROUPS)
  private Map<String, String> termGroups = new HashMap<>();

  public static final String SERIALIZED_NAME_PREFERRED_TERM_GROUPS = "preferredTermGroups";
  @SerializedName(SERIALIZED_NAME_PREFERRED_TERM_GROUPS)
  private List<String> preferredTermGroups;

  public TerminologyMetadata() {
  }

  public TerminologyMetadata uri(String uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * Get uri
   * @return uri
  **/
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }


  public void setUri(String uri) {
    this.uri = uri;
  }


  public TerminologyMetadata ct(Integer ct) {
    
    this.ct = ct;
    return this;
  }

   /**
   * Get ct
   * @return ct
  **/
  @javax.annotation.Nullable
  public Integer getCt() {
    return ct;
  }


  public void setCt(Integer ct) {
    this.ct = ct;
  }


  public TerminologyMetadata uiLabel(String uiLabel) {
    
    this.uiLabel = uiLabel;
    return this;
  }

   /**
   * Get uiLabel
   * @return uiLabel
  **/
  @javax.annotation.Nullable
  public String getUiLabel() {
    return uiLabel;
  }


  public void setUiLabel(String uiLabel) {
    this.uiLabel = uiLabel;
  }


  public TerminologyMetadata maxVersions(Integer maxVersions) {
    
    this.maxVersions = maxVersions;
    return this;
  }

   /**
   * Get maxVersions
   * @return maxVersions
  **/
  @javax.annotation.Nullable
  public Integer getMaxVersions() {
    return maxVersions;
  }


  public void setMaxVersions(Integer maxVersions) {
    this.maxVersions = maxVersions;
  }


  public TerminologyMetadata loader(String loader) {
    
    this.loader = loader;
    return this;
  }

   /**
   * Get loader
   * @return loader
  **/
  @javax.annotation.Nullable
  public String getLoader() {
    return loader;
  }


  public void setLoader(String loader) {
    this.loader = loader;
  }


  public TerminologyMetadata code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * Get code
   * @return code
  **/
  @javax.annotation.Nullable
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public TerminologyMetadata conceptStatus(String conceptStatus) {
    
    this.conceptStatus = conceptStatus;
    return this;
  }

   /**
   * Get conceptStatus
   * @return conceptStatus
  **/
  @javax.annotation.Nullable
  public String getConceptStatus() {
    return conceptStatus;
  }


  public void setConceptStatus(String conceptStatus) {
    this.conceptStatus = conceptStatus;
  }


  public TerminologyMetadata conceptStatuses(List<String> conceptStatuses) {
    
    this.conceptStatuses = conceptStatuses;
    return this;
  }

  public TerminologyMetadata addConceptStatusesItem(String conceptStatusesItem) {
    if (this.conceptStatuses == null) {
      this.conceptStatuses = new ArrayList<>();
    }
    this.conceptStatuses.add(conceptStatusesItem);
    return this;
  }

   /**
   * Get conceptStatuses
   * @return conceptStatuses
  **/
  @javax.annotation.Nullable
  public List<String> getConceptStatuses() {
    return conceptStatuses;
  }


  public void setConceptStatuses(List<String> conceptStatuses) {
    this.conceptStatuses = conceptStatuses;
  }


  public TerminologyMetadata retiredStatusValue(String retiredStatusValue) {
    
    this.retiredStatusValue = retiredStatusValue;
    return this;
  }

   /**
   * Get retiredStatusValue
   * @return retiredStatusValue
  **/
  @javax.annotation.Nullable
  public String getRetiredStatusValue() {
    return retiredStatusValue;
  }


  public void setRetiredStatusValue(String retiredStatusValue) {
    this.retiredStatusValue = retiredStatusValue;
  }


  public TerminologyMetadata preferredName(String preferredName) {
    
    this.preferredName = preferredName;
    return this;
  }

   /**
   * Get preferredName
   * @return preferredName
  **/
  @javax.annotation.Nullable
  public String getPreferredName() {
    return preferredName;
  }


  public void setPreferredName(String preferredName) {
    this.preferredName = preferredName;
  }


  public TerminologyMetadata relationshipToTarget(String relationshipToTarget) {
    
    this.relationshipToTarget = relationshipToTarget;
    return this;
  }

   /**
   * Get relationshipToTarget
   * @return relationshipToTarget
  **/
  @javax.annotation.Nullable
  public String getRelationshipToTarget() {
    return relationshipToTarget;
  }


  public void setRelationshipToTarget(String relationshipToTarget) {
    this.relationshipToTarget = relationshipToTarget;
  }


  public TerminologyMetadata synonym(Set<String> synonym) {
    
    this.synonym = synonym;
    return this;
  }

  public TerminologyMetadata addSynonymItem(String synonymItem) {
    if (this.synonym == null) {
      this.synonym = new LinkedHashSet<>();
    }
    this.synonym.add(synonymItem);
    return this;
  }

   /**
   * Get synonym
   * @return synonym
  **/
  @javax.annotation.Nullable
  public Set<String> getSynonym() {
    return synonym;
  }


  public void setSynonym(Set<String> synonym) {
    this.synonym = synonym;
  }


  public TerminologyMetadata synonymTermType(String synonymTermType) {
    
    this.synonymTermType = synonymTermType;
    return this;
  }

   /**
   * Get synonymTermType
   * @return synonymTermType
  **/
  @javax.annotation.Nullable
  public String getSynonymTermType() {
    return synonymTermType;
  }


  public void setSynonymTermType(String synonymTermType) {
    this.synonymTermType = synonymTermType;
  }


  public TerminologyMetadata synonymSource(String synonymSource) {
    
    this.synonymSource = synonymSource;
    return this;
  }

   /**
   * Get synonymSource
   * @return synonymSource
  **/
  @javax.annotation.Nullable
  public String getSynonymSource() {
    return synonymSource;
  }


  public void setSynonymSource(String synonymSource) {
    this.synonymSource = synonymSource;
  }


  public TerminologyMetadata synonymCode(String synonymCode) {
    
    this.synonymCode = synonymCode;
    return this;
  }

   /**
   * Get synonymCode
   * @return synonymCode
  **/
  @javax.annotation.Nullable
  public String getSynonymCode() {
    return synonymCode;
  }


  public void setSynonymCode(String synonymCode) {
    this.synonymCode = synonymCode;
  }


  public TerminologyMetadata synonymSubSource(String synonymSubSource) {
    
    this.synonymSubSource = synonymSubSource;
    return this;
  }

   /**
   * Get synonymSubSource
   * @return synonymSubSource
  **/
  @javax.annotation.Nullable
  public String getSynonymSubSource() {
    return synonymSubSource;
  }


  public void setSynonymSubSource(String synonymSubSource) {
    this.synonymSubSource = synonymSubSource;
  }


  public TerminologyMetadata definition(Set<String> definition) {
    
    this.definition = definition;
    return this;
  }

  public TerminologyMetadata addDefinitionItem(String definitionItem) {
    if (this.definition == null) {
      this.definition = new LinkedHashSet<>();
    }
    this.definition.add(definitionItem);
    return this;
  }

   /**
   * Get definition
   * @return definition
  **/
  @javax.annotation.Nullable
  public Set<String> getDefinition() {
    return definition;
  }


  public void setDefinition(Set<String> definition) {
    this.definition = definition;
  }


  public TerminologyMetadata definitionSource(String definitionSource) {
    
    this.definitionSource = definitionSource;
    return this;
  }

   /**
   * Get definitionSource
   * @return definitionSource
  **/
  @javax.annotation.Nullable
  public String getDefinitionSource() {
    return definitionSource;
  }


  public void setDefinitionSource(String definitionSource) {
    this.definitionSource = definitionSource;
  }


  public TerminologyMetadata mapRelation(String mapRelation) {
    
    this.mapRelation = mapRelation;
    return this;
  }

   /**
   * Get mapRelation
   * @return mapRelation
  **/
  @javax.annotation.Nullable
  public String getMapRelation() {
    return mapRelation;
  }


  public void setMapRelation(String mapRelation) {
    this.mapRelation = mapRelation;
  }


  public TerminologyMetadata map(String map) {
    
    this.map = map;
    return this;
  }

   /**
   * Get map
   * @return map
  **/
  @javax.annotation.Nullable
  public String getMap() {
    return map;
  }


  public void setMap(String map) {
    this.map = map;
  }


  public TerminologyMetadata mapTarget(String mapTarget) {
    
    this.mapTarget = mapTarget;
    return this;
  }

   /**
   * Get mapTarget
   * @return mapTarget
  **/
  @javax.annotation.Nullable
  public String getMapTarget() {
    return mapTarget;
  }


  public void setMapTarget(String mapTarget) {
    this.mapTarget = mapTarget;
  }


  public TerminologyMetadata mapTargetTermType(String mapTargetTermType) {
    
    this.mapTargetTermType = mapTargetTermType;
    return this;
  }

   /**
   * Get mapTargetTermType
   * @return mapTargetTermType
  **/
  @javax.annotation.Nullable
  public String getMapTargetTermType() {
    return mapTargetTermType;
  }


  public void setMapTargetTermType(String mapTargetTermType) {
    this.mapTargetTermType = mapTargetTermType;
  }


  public TerminologyMetadata mapTargetTerminology(String mapTargetTerminology) {
    
    this.mapTargetTerminology = mapTargetTerminology;
    return this;
  }

   /**
   * Get mapTargetTerminology
   * @return mapTargetTerminology
  **/
  @javax.annotation.Nullable
  public String getMapTargetTerminology() {
    return mapTargetTerminology;
  }


  public void setMapTargetTerminology(String mapTargetTerminology) {
    this.mapTargetTerminology = mapTargetTerminology;
  }


  public TerminologyMetadata mapTargetTerminologyVersion(String mapTargetTerminologyVersion) {
    
    this.mapTargetTerminologyVersion = mapTargetTerminologyVersion;
    return this;
  }

   /**
   * Get mapTargetTerminologyVersion
   * @return mapTargetTerminologyVersion
  **/
  @javax.annotation.Nullable
  public String getMapTargetTerminologyVersion() {
    return mapTargetTerminologyVersion;
  }


  public void setMapTargetTerminologyVersion(String mapTargetTerminologyVersion) {
    this.mapTargetTerminologyVersion = mapTargetTerminologyVersion;
  }


  public TerminologyMetadata sources(Map<String, String> sources) {
    
    this.sources = sources;
    return this;
  }

  public TerminologyMetadata putSourcesItem(String key, String sourcesItem) {
    if (this.sources == null) {
      this.sources = new HashMap<>();
    }
    this.sources.put(key, sourcesItem);
    return this;
  }

   /**
   * Get sources
   * @return sources
  **/
  @javax.annotation.Nullable
  public Map<String, String> getSources() {
    return sources;
  }


  public void setSources(Map<String, String> sources) {
    this.sources = sources;
  }


  public TerminologyMetadata detailsColumns(Map<String, Boolean> detailsColumns) {
    
    this.detailsColumns = detailsColumns;
    return this;
  }

  public TerminologyMetadata putDetailsColumnsItem(String key, Boolean detailsColumnsItem) {
    if (this.detailsColumns == null) {
      this.detailsColumns = new HashMap<>();
    }
    this.detailsColumns.put(key, detailsColumnsItem);
    return this;
  }

   /**
   * Get detailsColumns
   * @return detailsColumns
  **/
  @javax.annotation.Nullable
  public Map<String, Boolean> getDetailsColumns() {
    return detailsColumns;
  }


  public void setDetailsColumns(Map<String, Boolean> detailsColumns) {
    this.detailsColumns = detailsColumns;
  }


  public TerminologyMetadata hierarchy(Boolean hierarchy) {
    
    this.hierarchy = hierarchy;
    return this;
  }

   /**
   * Get hierarchy
   * @return hierarchy
  **/
  @javax.annotation.Nullable
  public Boolean getHierarchy() {
    return hierarchy;
  }


  public void setHierarchy(Boolean hierarchy) {
    this.hierarchy = hierarchy;
  }


  public TerminologyMetadata history(Boolean history) {
    
    this.history = history;
    return this;
  }

   /**
   * Get history
   * @return history
  **/
  @javax.annotation.Nullable
  public Boolean getHistory() {
    return history;
  }


  public void setHistory(Boolean history) {
    this.history = history;
  }


  public TerminologyMetadata mapsets(Boolean mapsets) {
    
    this.mapsets = mapsets;
    return this;
  }

   /**
   * Get mapsets
   * @return mapsets
  **/
  @javax.annotation.Nullable
  public Boolean getMapsets() {
    return mapsets;
  }


  public void setMapsets(Boolean mapsets) {
    this.mapsets = mapsets;
  }


  public TerminologyMetadata sourceCt(Integer sourceCt) {
    
    this.sourceCt = sourceCt;
    return this;
  }

   /**
   * Get sourceCt
   * @return sourceCt
  **/
  @javax.annotation.Nullable
  public Integer getSourceCt() {
    return sourceCt;
  }


  public void setSourceCt(Integer sourceCt) {
    this.sourceCt = sourceCt;
  }


  public TerminologyMetadata definitionSourceSet(Set<String> definitionSourceSet) {
    
    this.definitionSourceSet = definitionSourceSet;
    return this;
  }

  public TerminologyMetadata addDefinitionSourceSetItem(String definitionSourceSetItem) {
    if (this.definitionSourceSet == null) {
      this.definitionSourceSet = new LinkedHashSet<>();
    }
    this.definitionSourceSet.add(definitionSourceSetItem);
    return this;
  }

   /**
   * Get definitionSourceSet
   * @return definitionSourceSet
  **/
  @javax.annotation.Nullable
  public Set<String> getDefinitionSourceSet() {
    return definitionSourceSet;
  }


  public void setDefinitionSourceSet(Set<String> definitionSourceSet) {
    this.definitionSourceSet = definitionSourceSet;
  }


  public TerminologyMetadata synonymSourceSet(Set<String> synonymSourceSet) {
    
    this.synonymSourceSet = synonymSourceSet;
    return this;
  }

  public TerminologyMetadata addSynonymSourceSetItem(String synonymSourceSetItem) {
    if (this.synonymSourceSet == null) {
      this.synonymSourceSet = new LinkedHashSet<>();
    }
    this.synonymSourceSet.add(synonymSourceSetItem);
    return this;
  }

   /**
   * Get synonymSourceSet
   * @return synonymSourceSet
  **/
  @javax.annotation.Nullable
  public Set<String> getSynonymSourceSet() {
    return synonymSourceSet;
  }


  public void setSynonymSourceSet(Set<String> synonymSourceSet) {
    this.synonymSourceSet = synonymSourceSet;
  }


  public TerminologyMetadata termTypes(Map<String, String> termTypes) {
    
    this.termTypes = termTypes;
    return this;
  }

  public TerminologyMetadata putTermTypesItem(String key, String termTypesItem) {
    if (this.termTypes == null) {
      this.termTypes = new HashMap<>();
    }
    this.termTypes.put(key, termTypesItem);
    return this;
  }

   /**
   * Get termTypes
   * @return termTypes
  **/
  @javax.annotation.Nullable
  public Map<String, String> getTermTypes() {
    return termTypes;
  }


  public void setTermTypes(Map<String, String> termTypes) {
    this.termTypes = termTypes;
  }


  public TerminologyMetadata subsetPrefix(String subsetPrefix) {
    
    this.subsetPrefix = subsetPrefix;
    return this;
  }

   /**
   * Get subsetPrefix
   * @return subsetPrefix
  **/
  @javax.annotation.Nullable
  public String getSubsetPrefix() {
    return subsetPrefix;
  }


  public void setSubsetPrefix(String subsetPrefix) {
    this.subsetPrefix = subsetPrefix;
  }


  public TerminologyMetadata subsetLink(String subsetLink) {
    
    this.subsetLink = subsetLink;
    return this;
  }

   /**
   * Get subsetLink
   * @return subsetLink
  **/
  @javax.annotation.Nullable
  public String getSubsetLink() {
    return subsetLink;
  }


  public void setSubsetLink(String subsetLink) {
    this.subsetLink = subsetLink;
  }


  public TerminologyMetadata sourcesToRemove(Set<String> sourcesToRemove) {
    
    this.sourcesToRemove = sourcesToRemove;
    return this;
  }

  public TerminologyMetadata addSourcesToRemoveItem(String sourcesToRemoveItem) {
    if (this.sourcesToRemove == null) {
      this.sourcesToRemove = new LinkedHashSet<>();
    }
    this.sourcesToRemove.add(sourcesToRemoveItem);
    return this;
  }

   /**
   * Get sourcesToRemove
   * @return sourcesToRemove
  **/
  @javax.annotation.Nullable
  public Set<String> getSourcesToRemove() {
    return sourcesToRemove;
  }


  public void setSourcesToRemove(Set<String> sourcesToRemove) {
    this.sourcesToRemove = sourcesToRemove;
  }


  public TerminologyMetadata subsetMember(Set<String> subsetMember) {
    
    this.subsetMember = subsetMember;
    return this;
  }

  public TerminologyMetadata addSubsetMemberItem(String subsetMemberItem) {
    if (this.subsetMember == null) {
      this.subsetMember = new LinkedHashSet<>();
    }
    this.subsetMember.add(subsetMemberItem);
    return this;
  }

   /**
   * Get subsetMember
   * @return subsetMember
  **/
  @javax.annotation.Nullable
  public Set<String> getSubsetMember() {
    return subsetMember;
  }


  public void setSubsetMember(Set<String> subsetMember) {
    this.subsetMember = subsetMember;
  }


  public TerminologyMetadata unpublished(Set<String> unpublished) {
    
    this.unpublished = unpublished;
    return this;
  }

  public TerminologyMetadata addUnpublishedItem(String unpublishedItem) {
    if (this.unpublished == null) {
      this.unpublished = new LinkedHashSet<>();
    }
    this.unpublished.add(unpublishedItem);
    return this;
  }

   /**
   * Get unpublished
   * @return unpublished
  **/
  @javax.annotation.Nullable
  public Set<String> getUnpublished() {
    return unpublished;
  }


  public void setUnpublished(Set<String> unpublished) {
    this.unpublished = unpublished;
  }


  public TerminologyMetadata monthlyDb(String monthlyDb) {
    
    this.monthlyDb = monthlyDb;
    return this;
  }

   /**
   * Get monthlyDb
   * @return monthlyDb
  **/
  @javax.annotation.Nullable
  public String getMonthlyDb() {
    return monthlyDb;
  }


  public void setMonthlyDb(String monthlyDb) {
    this.monthlyDb = monthlyDb;
  }


  public TerminologyMetadata subset(Set<String> subset) {
    
    this.subset = subset;
    return this;
  }

  public TerminologyMetadata addSubsetItem(String subsetItem) {
    if (this.subset == null) {
      this.subset = new LinkedHashSet<>();
    }
    this.subset.add(subsetItem);
    return this;
  }

   /**
   * Get subset
   * @return subset
  **/
  @javax.annotation.Nullable
  public Set<String> getSubset() {
    return subset;
  }


  public void setSubset(Set<String> subset) {
    this.subset = subset;
  }


  public TerminologyMetadata licenseText(String licenseText) {
    
    this.licenseText = licenseText;
    return this;
  }

   /**
   * Get licenseText
   * @return licenseText
  **/
  @javax.annotation.Nullable
  public String getLicenseText() {
    return licenseText;
  }


  public void setLicenseText(String licenseText) {
    this.licenseText = licenseText;
  }


  public TerminologyMetadata metaConceptField(String metaConceptField) {
    
    this.metaConceptField = metaConceptField;
    return this;
  }

   /**
   * Get metaConceptField
   * @return metaConceptField
  **/
  @javax.annotation.Nullable
  public String getMetaConceptField() {
    return metaConceptField;
  }


  public void setMetaConceptField(String metaConceptField) {
    this.metaConceptField = metaConceptField;
  }


  public TerminologyMetadata preferredTermTypes(List<String> preferredTermTypes) {
    
    this.preferredTermTypes = preferredTermTypes;
    return this;
  }

  public TerminologyMetadata addPreferredTermTypesItem(String preferredTermTypesItem) {
    if (this.preferredTermTypes == null) {
      this.preferredTermTypes = new ArrayList<>();
    }
    this.preferredTermTypes.add(preferredTermTypesItem);
    return this;
  }

   /**
   * Get preferredTermTypes
   * @return preferredTermTypes
  **/
  @javax.annotation.Nullable
  public List<String> getPreferredTermTypes() {
    return preferredTermTypes;
  }


  public void setPreferredTermTypes(List<String> preferredTermTypes) {
    this.preferredTermTypes = preferredTermTypes;
  }


  public TerminologyMetadata codeLabel(String codeLabel) {
    
    this.codeLabel = codeLabel;
    return this;
  }

   /**
   * Get codeLabel
   * @return codeLabel
  **/
  @javax.annotation.Nullable
  public String getCodeLabel() {
    return codeLabel;
  }


  public void setCodeLabel(String codeLabel) {
    this.codeLabel = codeLabel;
  }


  public TerminologyMetadata welcomeText(String welcomeText) {
    
    this.welcomeText = welcomeText;
    return this;
  }

   /**
   * Get welcomeText
   * @return welcomeText
  **/
  @javax.annotation.Nullable
  public String getWelcomeText() {
    return welcomeText;
  }


  public void setWelcomeText(String welcomeText) {
    this.welcomeText = welcomeText;
  }


  public TerminologyMetadata synonymTermGroup(String synonymTermGroup) {
    
    this.synonymTermGroup = synonymTermGroup;
    return this;
  }

   /**
   * Get synonymTermGroup
   * @return synonymTermGroup
  **/
  @javax.annotation.Nullable
  public String getSynonymTermGroup() {
    return synonymTermGroup;
  }


  public void setSynonymTermGroup(String synonymTermGroup) {
    this.synonymTermGroup = synonymTermGroup;
  }


  public TerminologyMetadata mapTargetTermGroup(String mapTargetTermGroup) {
    
    this.mapTargetTermGroup = mapTargetTermGroup;
    return this;
  }

   /**
   * Get mapTargetTermGroup
   * @return mapTargetTermGroup
  **/
  @javax.annotation.Nullable
  public String getMapTargetTermGroup() {
    return mapTargetTermGroup;
  }


  public void setMapTargetTermGroup(String mapTargetTermGroup) {
    this.mapTargetTermGroup = mapTargetTermGroup;
  }


  public TerminologyMetadata termGroups(Map<String, String> termGroups) {
    
    this.termGroups = termGroups;
    return this;
  }

  public TerminologyMetadata putTermGroupsItem(String key, String termGroupsItem) {
    if (this.termGroups == null) {
      this.termGroups = new HashMap<>();
    }
    this.termGroups.put(key, termGroupsItem);
    return this;
  }

   /**
   * Get termGroups
   * @return termGroups
  **/
  @javax.annotation.Nullable
  public Map<String, String> getTermGroups() {
    return termGroups;
  }


  public void setTermGroups(Map<String, String> termGroups) {
    this.termGroups = termGroups;
  }


  public TerminologyMetadata preferredTermGroups(List<String> preferredTermGroups) {
    
    this.preferredTermGroups = preferredTermGroups;
    return this;
  }

  public TerminologyMetadata addPreferredTermGroupsItem(String preferredTermGroupsItem) {
    if (this.preferredTermGroups == null) {
      this.preferredTermGroups = new ArrayList<>();
    }
    this.preferredTermGroups.add(preferredTermGroupsItem);
    return this;
  }

   /**
   * Get preferredTermGroups
   * @return preferredTermGroups
  **/
  @javax.annotation.Nullable
  public List<String> getPreferredTermGroups() {
    return preferredTermGroups;
  }


  public void setPreferredTermGroups(List<String> preferredTermGroups) {
    this.preferredTermGroups = preferredTermGroups;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TerminologyMetadata terminologyMetadata = (TerminologyMetadata) o;
    return Objects.equals(this.uri, terminologyMetadata.uri) &&
        Objects.equals(this.ct, terminologyMetadata.ct) &&
        Objects.equals(this.uiLabel, terminologyMetadata.uiLabel) &&
        Objects.equals(this.maxVersions, terminologyMetadata.maxVersions) &&
        Objects.equals(this.loader, terminologyMetadata.loader) &&
        Objects.equals(this.code, terminologyMetadata.code) &&
        Objects.equals(this.conceptStatus, terminologyMetadata.conceptStatus) &&
        Objects.equals(this.conceptStatuses, terminologyMetadata.conceptStatuses) &&
        Objects.equals(this.retiredStatusValue, terminologyMetadata.retiredStatusValue) &&
        Objects.equals(this.preferredName, terminologyMetadata.preferredName) &&
        Objects.equals(this.relationshipToTarget, terminologyMetadata.relationshipToTarget) &&
        Objects.equals(this.synonym, terminologyMetadata.synonym) &&
        Objects.equals(this.synonymTermType, terminologyMetadata.synonymTermType) &&
        Objects.equals(this.synonymSource, terminologyMetadata.synonymSource) &&
        Objects.equals(this.synonymCode, terminologyMetadata.synonymCode) &&
        Objects.equals(this.synonymSubSource, terminologyMetadata.synonymSubSource) &&
        Objects.equals(this.definition, terminologyMetadata.definition) &&
        Objects.equals(this.definitionSource, terminologyMetadata.definitionSource) &&
        Objects.equals(this.mapRelation, terminologyMetadata.mapRelation) &&
        Objects.equals(this.map, terminologyMetadata.map) &&
        Objects.equals(this.mapTarget, terminologyMetadata.mapTarget) &&
        Objects.equals(this.mapTargetTermType, terminologyMetadata.mapTargetTermType) &&
        Objects.equals(this.mapTargetTerminology, terminologyMetadata.mapTargetTerminology) &&
        Objects.equals(this.mapTargetTerminologyVersion, terminologyMetadata.mapTargetTerminologyVersion) &&
        Objects.equals(this.sources, terminologyMetadata.sources) &&
        Objects.equals(this.detailsColumns, terminologyMetadata.detailsColumns) &&
        Objects.equals(this.hierarchy, terminologyMetadata.hierarchy) &&
        Objects.equals(this.history, terminologyMetadata.history) &&
        Objects.equals(this.mapsets, terminologyMetadata.mapsets) &&
        Objects.equals(this.sourceCt, terminologyMetadata.sourceCt) &&
        Objects.equals(this.definitionSourceSet, terminologyMetadata.definitionSourceSet) &&
        Objects.equals(this.synonymSourceSet, terminologyMetadata.synonymSourceSet) &&
        Objects.equals(this.termTypes, terminologyMetadata.termTypes) &&
        Objects.equals(this.subsetPrefix, terminologyMetadata.subsetPrefix) &&
        Objects.equals(this.subsetLink, terminologyMetadata.subsetLink) &&
        Objects.equals(this.sourcesToRemove, terminologyMetadata.sourcesToRemove) &&
        Objects.equals(this.subsetMember, terminologyMetadata.subsetMember) &&
        Objects.equals(this.unpublished, terminologyMetadata.unpublished) &&
        Objects.equals(this.monthlyDb, terminologyMetadata.monthlyDb) &&
        Objects.equals(this.subset, terminologyMetadata.subset) &&
        Objects.equals(this.licenseText, terminologyMetadata.licenseText) &&
        Objects.equals(this.metaConceptField, terminologyMetadata.metaConceptField) &&
        Objects.equals(this.preferredTermTypes, terminologyMetadata.preferredTermTypes) &&
        Objects.equals(this.codeLabel, terminologyMetadata.codeLabel) &&
        Objects.equals(this.welcomeText, terminologyMetadata.welcomeText) &&
        Objects.equals(this.synonymTermGroup, terminologyMetadata.synonymTermGroup) &&
        Objects.equals(this.mapTargetTermGroup, terminologyMetadata.mapTargetTermGroup) &&
        Objects.equals(this.termGroups, terminologyMetadata.termGroups) &&
        Objects.equals(this.preferredTermGroups, terminologyMetadata.preferredTermGroups);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, ct, uiLabel, maxVersions, loader, code, conceptStatus, conceptStatuses, retiredStatusValue, preferredName, relationshipToTarget, synonym, synonymTermType, synonymSource, synonymCode, synonymSubSource, definition, definitionSource, mapRelation, map, mapTarget, mapTargetTermType, mapTargetTerminology, mapTargetTerminologyVersion, sources, detailsColumns, hierarchy, history, mapsets, sourceCt, definitionSourceSet, synonymSourceSet, termTypes, subsetPrefix, subsetLink, sourcesToRemove, subsetMember, unpublished, monthlyDb, subset, licenseText, metaConceptField, preferredTermTypes, codeLabel, welcomeText, synonymTermGroup, mapTargetTermGroup, termGroups, preferredTermGroups);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TerminologyMetadata {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    ct: ").append(toIndentedString(ct)).append("\n");
    sb.append("    uiLabel: ").append(toIndentedString(uiLabel)).append("\n");
    sb.append("    maxVersions: ").append(toIndentedString(maxVersions)).append("\n");
    sb.append("    loader: ").append(toIndentedString(loader)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    conceptStatus: ").append(toIndentedString(conceptStatus)).append("\n");
    sb.append("    conceptStatuses: ").append(toIndentedString(conceptStatuses)).append("\n");
    sb.append("    retiredStatusValue: ").append(toIndentedString(retiredStatusValue)).append("\n");
    sb.append("    preferredName: ").append(toIndentedString(preferredName)).append("\n");
    sb.append("    relationshipToTarget: ").append(toIndentedString(relationshipToTarget)).append("\n");
    sb.append("    synonym: ").append(toIndentedString(synonym)).append("\n");
    sb.append("    synonymTermType: ").append(toIndentedString(synonymTermType)).append("\n");
    sb.append("    synonymSource: ").append(toIndentedString(synonymSource)).append("\n");
    sb.append("    synonymCode: ").append(toIndentedString(synonymCode)).append("\n");
    sb.append("    synonymSubSource: ").append(toIndentedString(synonymSubSource)).append("\n");
    sb.append("    definition: ").append(toIndentedString(definition)).append("\n");
    sb.append("    definitionSource: ").append(toIndentedString(definitionSource)).append("\n");
    sb.append("    mapRelation: ").append(toIndentedString(mapRelation)).append("\n");
    sb.append("    map: ").append(toIndentedString(map)).append("\n");
    sb.append("    mapTarget: ").append(toIndentedString(mapTarget)).append("\n");
    sb.append("    mapTargetTermType: ").append(toIndentedString(mapTargetTermType)).append("\n");
    sb.append("    mapTargetTerminology: ").append(toIndentedString(mapTargetTerminology)).append("\n");
    sb.append("    mapTargetTerminologyVersion: ").append(toIndentedString(mapTargetTerminologyVersion)).append("\n");
    sb.append("    sources: ").append(toIndentedString(sources)).append("\n");
    sb.append("    detailsColumns: ").append(toIndentedString(detailsColumns)).append("\n");
    sb.append("    hierarchy: ").append(toIndentedString(hierarchy)).append("\n");
    sb.append("    history: ").append(toIndentedString(history)).append("\n");
    sb.append("    mapsets: ").append(toIndentedString(mapsets)).append("\n");
    sb.append("    sourceCt: ").append(toIndentedString(sourceCt)).append("\n");
    sb.append("    definitionSourceSet: ").append(toIndentedString(definitionSourceSet)).append("\n");
    sb.append("    synonymSourceSet: ").append(toIndentedString(synonymSourceSet)).append("\n");
    sb.append("    termTypes: ").append(toIndentedString(termTypes)).append("\n");
    sb.append("    subsetPrefix: ").append(toIndentedString(subsetPrefix)).append("\n");
    sb.append("    subsetLink: ").append(toIndentedString(subsetLink)).append("\n");
    sb.append("    sourcesToRemove: ").append(toIndentedString(sourcesToRemove)).append("\n");
    sb.append("    subsetMember: ").append(toIndentedString(subsetMember)).append("\n");
    sb.append("    unpublished: ").append(toIndentedString(unpublished)).append("\n");
    sb.append("    monthlyDb: ").append(toIndentedString(monthlyDb)).append("\n");
    sb.append("    subset: ").append(toIndentedString(subset)).append("\n");
    sb.append("    licenseText: ").append(toIndentedString(licenseText)).append("\n");
    sb.append("    metaConceptField: ").append(toIndentedString(metaConceptField)).append("\n");
    sb.append("    preferredTermTypes: ").append(toIndentedString(preferredTermTypes)).append("\n");
    sb.append("    codeLabel: ").append(toIndentedString(codeLabel)).append("\n");
    sb.append("    welcomeText: ").append(toIndentedString(welcomeText)).append("\n");
    sb.append("    synonymTermGroup: ").append(toIndentedString(synonymTermGroup)).append("\n");
    sb.append("    mapTargetTermGroup: ").append(toIndentedString(mapTargetTermGroup)).append("\n");
    sb.append("    termGroups: ").append(toIndentedString(termGroups)).append("\n");
    sb.append("    preferredTermGroups: ").append(toIndentedString(preferredTermGroups)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("uri");
    openapiFields.add("ct");
    openapiFields.add("uiLabel");
    openapiFields.add("maxVersions");
    openapiFields.add("loader");
    openapiFields.add("code");
    openapiFields.add("conceptStatus");
    openapiFields.add("conceptStatuses");
    openapiFields.add("retiredStatusValue");
    openapiFields.add("preferredName");
    openapiFields.add("relationshipToTarget");
    openapiFields.add("synonym");
    openapiFields.add("synonymTermType");
    openapiFields.add("synonymSource");
    openapiFields.add("synonymCode");
    openapiFields.add("synonymSubSource");
    openapiFields.add("definition");
    openapiFields.add("definitionSource");
    openapiFields.add("mapRelation");
    openapiFields.add("map");
    openapiFields.add("mapTarget");
    openapiFields.add("mapTargetTermType");
    openapiFields.add("mapTargetTerminology");
    openapiFields.add("mapTargetTerminologyVersion");
    openapiFields.add("sources");
    openapiFields.add("detailsColumns");
    openapiFields.add("hierarchy");
    openapiFields.add("history");
    openapiFields.add("mapsets");
    openapiFields.add("sourceCt");
    openapiFields.add("definitionSourceSet");
    openapiFields.add("synonymSourceSet");
    openapiFields.add("termTypes");
    openapiFields.add("subsetPrefix");
    openapiFields.add("subsetLink");
    openapiFields.add("sourcesToRemove");
    openapiFields.add("subsetMember");
    openapiFields.add("unpublished");
    openapiFields.add("monthlyDb");
    openapiFields.add("subset");
    openapiFields.add("licenseText");
    openapiFields.add("metaConceptField");
    openapiFields.add("preferredTermTypes");
    openapiFields.add("codeLabel");
    openapiFields.add("welcomeText");
    openapiFields.add("synonymTermGroup");
    openapiFields.add("mapTargetTermGroup");
    openapiFields.add("termGroups");
    openapiFields.add("preferredTermGroups");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TerminologyMetadata
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TerminologyMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TerminologyMetadata is not found in the empty JSON string", TerminologyMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TerminologyMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TerminologyMetadata` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) && !jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      if ((jsonObj.get("uiLabel") != null && !jsonObj.get("uiLabel").isJsonNull()) && !jsonObj.get("uiLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uiLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uiLabel").toString()));
      }
      if ((jsonObj.get("loader") != null && !jsonObj.get("loader").isJsonNull()) && !jsonObj.get("loader").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loader` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loader").toString()));
      }
      if ((jsonObj.get("code") != null && !jsonObj.get("code").isJsonNull()) && !jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      if ((jsonObj.get("conceptStatus") != null && !jsonObj.get("conceptStatus").isJsonNull()) && !jsonObj.get("conceptStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conceptStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conceptStatus").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conceptStatuses") != null && !jsonObj.get("conceptStatuses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conceptStatuses` to be an array in the JSON string but got `%s`", jsonObj.get("conceptStatuses").toString()));
      }
      if ((jsonObj.get("retiredStatusValue") != null && !jsonObj.get("retiredStatusValue").isJsonNull()) && !jsonObj.get("retiredStatusValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retiredStatusValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retiredStatusValue").toString()));
      }
      if ((jsonObj.get("preferredName") != null && !jsonObj.get("preferredName").isJsonNull()) && !jsonObj.get("preferredName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preferredName").toString()));
      }
      if ((jsonObj.get("relationshipToTarget") != null && !jsonObj.get("relationshipToTarget").isJsonNull()) && !jsonObj.get("relationshipToTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `relationshipToTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("relationshipToTarget").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("synonym") != null && !jsonObj.get("synonym").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonym` to be an array in the JSON string but got `%s`", jsonObj.get("synonym").toString()));
      }
      if ((jsonObj.get("synonymTermType") != null && !jsonObj.get("synonymTermType").isJsonNull()) && !jsonObj.get("synonymTermType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymTermType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymTermType").toString()));
      }
      if ((jsonObj.get("synonymSource") != null && !jsonObj.get("synonymSource").isJsonNull()) && !jsonObj.get("synonymSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymSource").toString()));
      }
      if ((jsonObj.get("synonymCode") != null && !jsonObj.get("synonymCode").isJsonNull()) && !jsonObj.get("synonymCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymCode").toString()));
      }
      if ((jsonObj.get("synonymSubSource") != null && !jsonObj.get("synonymSubSource").isJsonNull()) && !jsonObj.get("synonymSubSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymSubSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymSubSource").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("definition") != null && !jsonObj.get("definition").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `definition` to be an array in the JSON string but got `%s`", jsonObj.get("definition").toString()));
      }
      if ((jsonObj.get("definitionSource") != null && !jsonObj.get("definitionSource").isJsonNull()) && !jsonObj.get("definitionSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definitionSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definitionSource").toString()));
      }
      if ((jsonObj.get("mapRelation") != null && !jsonObj.get("mapRelation").isJsonNull()) && !jsonObj.get("mapRelation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapRelation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapRelation").toString()));
      }
      if ((jsonObj.get("map") != null && !jsonObj.get("map").isJsonNull()) && !jsonObj.get("map").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `map` to be a primitive type in the JSON string but got `%s`", jsonObj.get("map").toString()));
      }
      if ((jsonObj.get("mapTarget") != null && !jsonObj.get("mapTarget").isJsonNull()) && !jsonObj.get("mapTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTarget").toString()));
      }
      if ((jsonObj.get("mapTargetTermType") != null && !jsonObj.get("mapTargetTermType").isJsonNull()) && !jsonObj.get("mapTargetTermType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTermType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTermType").toString()));
      }
      if ((jsonObj.get("mapTargetTerminology") != null && !jsonObj.get("mapTargetTerminology").isJsonNull()) && !jsonObj.get("mapTargetTerminology").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTerminology` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTerminology").toString()));
      }
      if ((jsonObj.get("mapTargetTerminologyVersion") != null && !jsonObj.get("mapTargetTerminologyVersion").isJsonNull()) && !jsonObj.get("mapTargetTerminologyVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTerminologyVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTerminologyVersion").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("definitionSourceSet") != null && !jsonObj.get("definitionSourceSet").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `definitionSourceSet` to be an array in the JSON string but got `%s`", jsonObj.get("definitionSourceSet").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("synonymSourceSet") != null && !jsonObj.get("synonymSourceSet").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymSourceSet` to be an array in the JSON string but got `%s`", jsonObj.get("synonymSourceSet").toString()));
      }
      if ((jsonObj.get("subsetPrefix") != null && !jsonObj.get("subsetPrefix").isJsonNull()) && !jsonObj.get("subsetPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subsetPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subsetPrefix").toString()));
      }
      if ((jsonObj.get("subsetLink") != null && !jsonObj.get("subsetLink").isJsonNull()) && !jsonObj.get("subsetLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subsetLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subsetLink").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sourcesToRemove") != null && !jsonObj.get("sourcesToRemove").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourcesToRemove` to be an array in the JSON string but got `%s`", jsonObj.get("sourcesToRemove").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subsetMember") != null && !jsonObj.get("subsetMember").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subsetMember` to be an array in the JSON string but got `%s`", jsonObj.get("subsetMember").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("unpublished") != null && !jsonObj.get("unpublished").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `unpublished` to be an array in the JSON string but got `%s`", jsonObj.get("unpublished").toString()));
      }
      if ((jsonObj.get("monthlyDb") != null && !jsonObj.get("monthlyDb").isJsonNull()) && !jsonObj.get("monthlyDb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monthlyDb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monthlyDb").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subset") != null && !jsonObj.get("subset").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subset` to be an array in the JSON string but got `%s`", jsonObj.get("subset").toString()));
      }
      if ((jsonObj.get("licenseText") != null && !jsonObj.get("licenseText").isJsonNull()) && !jsonObj.get("licenseText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenseText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("licenseText").toString()));
      }
      if ((jsonObj.get("metaConceptField") != null && !jsonObj.get("metaConceptField").isJsonNull()) && !jsonObj.get("metaConceptField").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metaConceptField` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metaConceptField").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preferredTermTypes") != null && !jsonObj.get("preferredTermTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredTermTypes` to be an array in the JSON string but got `%s`", jsonObj.get("preferredTermTypes").toString()));
      }
      if ((jsonObj.get("codeLabel") != null && !jsonObj.get("codeLabel").isJsonNull()) && !jsonObj.get("codeLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `codeLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("codeLabel").toString()));
      }
      if ((jsonObj.get("welcomeText") != null && !jsonObj.get("welcomeText").isJsonNull()) && !jsonObj.get("welcomeText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `welcomeText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("welcomeText").toString()));
      }
      if ((jsonObj.get("synonymTermGroup") != null && !jsonObj.get("synonymTermGroup").isJsonNull()) && !jsonObj.get("synonymTermGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymTermGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymTermGroup").toString()));
      }
      if ((jsonObj.get("mapTargetTermGroup") != null && !jsonObj.get("mapTargetTermGroup").isJsonNull()) && !jsonObj.get("mapTargetTermGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTermGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTermGroup").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preferredTermGroups") != null && !jsonObj.get("preferredTermGroups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredTermGroups` to be an array in the JSON string but got `%s`", jsonObj.get("preferredTermGroups").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TerminologyMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TerminologyMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TerminologyMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TerminologyMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<TerminologyMetadata>() {
           @Override
           public void write(JsonWriter out, TerminologyMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TerminologyMetadata read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TerminologyMetadata given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TerminologyMetadata
  * @throws IOException if the JSON string is invalid with respect to TerminologyMetadata
  */
  public static TerminologyMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TerminologyMetadata.class);
  }

 /**
  * Convert an instance of TerminologyMetadata to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


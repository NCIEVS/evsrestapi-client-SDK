/*
 * NCI EVS Rest API
 * Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>
 *
 * The version of the OpenAPI document: 1.7.2.RELEASE
 * Contact: NCIAppSupport@nih.gov
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package gov.nih.nci.evs.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import gov.nih.nci.evs.api.invoker.JSON;

/**
 * Represents additional terminology metadata
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-01T14:31:35.961802-08:00[America/Los_Angeles]")
public class TerminologyMetadata {
  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  private String uri;

  public static final String SERIALIZED_NAME_CT = "ct";
  @SerializedName(SERIALIZED_NAME_CT)
  private Integer ct;

  public static final String SERIALIZED_NAME_UI_LABEL = "uiLabel";
  @SerializedName(SERIALIZED_NAME_UI_LABEL)
  private String uiLabel;

  public static final String SERIALIZED_NAME_MAX_VERSIONS = "maxVersions";
  @SerializedName(SERIALIZED_NAME_MAX_VERSIONS)
  private Integer maxVersions;

  public static final String SERIALIZED_NAME_LOADER = "loader";
  @SerializedName(SERIALIZED_NAME_LOADER)
  private String loader;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_CONCEPT_STATUS = "conceptStatus";
  @SerializedName(SERIALIZED_NAME_CONCEPT_STATUS)
  private String conceptStatus;

  public static final String SERIALIZED_NAME_CONCEPT_STATUSES = "conceptStatuses";
  @SerializedName(SERIALIZED_NAME_CONCEPT_STATUSES)
  private List<String> conceptStatuses;

  public static final String SERIALIZED_NAME_RETIRED_STATUS_VALUE = "retiredStatusValue";
  @SerializedName(SERIALIZED_NAME_RETIRED_STATUS_VALUE)
  private String retiredStatusValue;

  public static final String SERIALIZED_NAME_PREFERRED_NAME = "preferredName";
  @SerializedName(SERIALIZED_NAME_PREFERRED_NAME)
  private String preferredName;

  public static final String SERIALIZED_NAME_RELATIONSHIP_TO_TARGET = "relationshipToTarget";
  @SerializedName(SERIALIZED_NAME_RELATIONSHIP_TO_TARGET)
  private String relationshipToTarget;

  public static final String SERIALIZED_NAME_SYNONYM = "synonym";
  @SerializedName(SERIALIZED_NAME_SYNONYM)
  private Set<String> synonym;

  public static final String SERIALIZED_NAME_SYNONYM_TERM_TYPE = "synonymTermType";
  @SerializedName(SERIALIZED_NAME_SYNONYM_TERM_TYPE)
  private String synonymTermType;

  public static final String SERIALIZED_NAME_SYNONYM_SOURCE = "synonymSource";
  @SerializedName(SERIALIZED_NAME_SYNONYM_SOURCE)
  private String synonymSource;

  public static final String SERIALIZED_NAME_SYNONYM_CODE = "synonymCode";
  @SerializedName(SERIALIZED_NAME_SYNONYM_CODE)
  private String synonymCode;

  public static final String SERIALIZED_NAME_SYNONYM_SUB_SOURCE = "synonymSubSource";
  @SerializedName(SERIALIZED_NAME_SYNONYM_SUB_SOURCE)
  private String synonymSubSource;

  public static final String SERIALIZED_NAME_DEFINITION = "definition";
  @SerializedName(SERIALIZED_NAME_DEFINITION)
  private Set<String> definition;

  public static final String SERIALIZED_NAME_DEFINITION_SOURCE = "definitionSource";
  @SerializedName(SERIALIZED_NAME_DEFINITION_SOURCE)
  private String definitionSource;

  public static final String SERIALIZED_NAME_MAP_RELATION = "mapRelation";
  @SerializedName(SERIALIZED_NAME_MAP_RELATION)
  private String mapRelation;

  public static final String SERIALIZED_NAME_MAP = "map";
  @SerializedName(SERIALIZED_NAME_MAP)
  private String map;

  public static final String SERIALIZED_NAME_MAP_TARGET = "mapTarget";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET)
  private String mapTarget;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERM_TYPE = "mapTargetTermType";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERM_TYPE)
  private String mapTargetTermType;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY = "mapTargetTerminology";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY)
  private String mapTargetTerminology;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY_VERSION = "mapTargetTerminologyVersion";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERMINOLOGY_VERSION)
  private String mapTargetTerminologyVersion;

  public static final String SERIALIZED_NAME_DETAILS_COLUMNS = "detailsColumns";
  @SerializedName(SERIALIZED_NAME_DETAILS_COLUMNS)
  private Map<String, Boolean> detailsColumns = new HashMap<>();

  public static final String SERIALIZED_NAME_HIERARCHY = "hierarchy";
  @SerializedName(SERIALIZED_NAME_HIERARCHY)
  private Boolean hierarchy;

  public static final String SERIALIZED_NAME_HISTORY = "history";
  @SerializedName(SERIALIZED_NAME_HISTORY)
  private Boolean history;

  public static final String SERIALIZED_NAME_SOURCE_CT = "sourceCt";
  @SerializedName(SERIALIZED_NAME_SOURCE_CT)
  private Integer sourceCt;

  public static final String SERIALIZED_NAME_TERM_TYPES = "termTypes";
  @SerializedName(SERIALIZED_NAME_TERM_TYPES)
  private Map<String, String> termTypes = new HashMap<>();

  public static final String SERIALIZED_NAME_SUBSET_LINK = "subsetLink";
  @SerializedName(SERIALIZED_NAME_SUBSET_LINK)
  private String subsetLink;

  public static final String SERIALIZED_NAME_SUBSET = "subset";
  @SerializedName(SERIALIZED_NAME_SUBSET)
  private Set<String> subset;

  public static final String SERIALIZED_NAME_LICENSE_TEXT = "licenseText";
  @SerializedName(SERIALIZED_NAME_LICENSE_TEXT)
  private String licenseText;

  public static final String SERIALIZED_NAME_META_CONCEPT_FIELD = "metaConceptField";
  @SerializedName(SERIALIZED_NAME_META_CONCEPT_FIELD)
  private String metaConceptField;

  public static final String SERIALIZED_NAME_PREFERRED_TERM_TYPES = "preferredTermTypes";
  @SerializedName(SERIALIZED_NAME_PREFERRED_TERM_TYPES)
  private List<String> preferredTermTypes;

  public static final String SERIALIZED_NAME_CODE_LABEL = "codeLabel";
  @SerializedName(SERIALIZED_NAME_CODE_LABEL)
  private String codeLabel;

  public static final String SERIALIZED_NAME_WELCOME_TEXT = "welcomeText";
  @SerializedName(SERIALIZED_NAME_WELCOME_TEXT)
  private String welcomeText;

  public static final String SERIALIZED_NAME_SYNONYM_TERM_GROUP = "synonymTermGroup";
  @SerializedName(SERIALIZED_NAME_SYNONYM_TERM_GROUP)
  private String synonymTermGroup;

  public static final String SERIALIZED_NAME_MAP_TARGET_TERM_GROUP = "mapTargetTermGroup";
  @SerializedName(SERIALIZED_NAME_MAP_TARGET_TERM_GROUP)
  private String mapTargetTermGroup;

  public static final String SERIALIZED_NAME_TERM_GROUPS = "termGroups";
  @SerializedName(SERIALIZED_NAME_TERM_GROUPS)
  private Map<String, String> termGroups = new HashMap<>();

  public static final String SERIALIZED_NAME_PREFERRED_TERM_GROUPS = "preferredTermGroups";
  @SerializedName(SERIALIZED_NAME_PREFERRED_TERM_GROUPS)
  private List<String> preferredTermGroups;

  public TerminologyMetadata() {
  }

  public TerminologyMetadata uri(String uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * URI for this element in an rdf-based source file
   * @return uri
  **/
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }


  public void setUri(String uri) {
    this.uri = uri;
  }


  public TerminologyMetadata ct(Integer ct) {
    
    this.ct = ct;
    return this;
  }

   /**
   * Used to indicate the total amount of data in cases where a limit is being applied
   * @return ct
  **/
  @javax.annotation.Nullable
  public Integer getCt() {
    return ct;
  }


  public void setCt(Integer ct) {
    this.ct = ct;
  }


  public TerminologyMetadata uiLabel(String uiLabel) {
    
    this.uiLabel = uiLabel;
    return this;
  }

   /**
   * Human-readable name for the terminology to use in a UI label
   * @return uiLabel
  **/
  @javax.annotation.Nullable
  public String getUiLabel() {
    return uiLabel;
  }


  public void setUiLabel(String uiLabel) {
    this.uiLabel = uiLabel;
  }


  public TerminologyMetadata maxVersions(Integer maxVersions) {
    
    this.maxVersions = maxVersions;
    return this;
  }

   /**
   * Max number of versions to keep at the same time
   * @return maxVersions
  **/
  @javax.annotation.Nullable
  public Integer getMaxVersions() {
    return maxVersions;
  }


  public void setMaxVersions(Integer maxVersions) {
    this.maxVersions = maxVersions;
  }


  public TerminologyMetadata loader(String loader) {
    
    this.loader = loader;
    return this;
  }

   /**
   * Label for the loader used to populate this data
   * @return loader
  **/
  @javax.annotation.Nullable
  public String getLoader() {
    return loader;
  }


  public void setLoader(String loader) {
    this.loader = loader;
  }


  public TerminologyMetadata code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return code
  **/
  @javax.annotation.Nullable
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public TerminologyMetadata conceptStatus(String conceptStatus) {
    
    this.conceptStatus = conceptStatus;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return conceptStatus
  **/
  @javax.annotation.Nullable
  public String getConceptStatus() {
    return conceptStatus;
  }


  public void setConceptStatus(String conceptStatus) {
    this.conceptStatus = conceptStatus;
  }


  public TerminologyMetadata conceptStatuses(List<String> conceptStatuses) {
    
    this.conceptStatuses = conceptStatuses;
    return this;
  }

  public TerminologyMetadata addConceptStatusesItem(String conceptStatusesItem) {
    if (this.conceptStatuses == null) {
      this.conceptStatuses = new ArrayList<>();
    }
    this.conceptStatuses.add(conceptStatusesItem);
    return this;
  }

   /**
   * Concept status values used by the terminology
   * @return conceptStatuses
  **/
  @javax.annotation.Nullable
  public List<String> getConceptStatuses() {
    return conceptStatuses;
  }


  public void setConceptStatuses(List<String> conceptStatuses) {
    this.conceptStatuses = conceptStatuses;
  }


  public TerminologyMetadata retiredStatusValue(String retiredStatusValue) {
    
    this.retiredStatusValue = retiredStatusValue;
    return this;
  }

   /**
   * Concept status value for retired concepts
   * @return retiredStatusValue
  **/
  @javax.annotation.Nullable
  public String getRetiredStatusValue() {
    return retiredStatusValue;
  }


  public void setRetiredStatusValue(String retiredStatusValue) {
    this.retiredStatusValue = retiredStatusValue;
  }


  public TerminologyMetadata preferredName(String preferredName) {
    
    this.preferredName = preferredName;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return preferredName
  **/
  @javax.annotation.Nullable
  public String getPreferredName() {
    return preferredName;
  }


  public void setPreferredName(String preferredName) {
    this.preferredName = preferredName;
  }


  public TerminologyMetadata relationshipToTarget(String relationshipToTarget) {
    
    this.relationshipToTarget = relationshipToTarget;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return relationshipToTarget
  **/
  @javax.annotation.Nullable
  public String getRelationshipToTarget() {
    return relationshipToTarget;
  }


  public void setRelationshipToTarget(String relationshipToTarget) {
    this.relationshipToTarget = relationshipToTarget;
  }


  public TerminologyMetadata synonym(Set<String> synonym) {
    
    this.synonym = synonym;
    return this;
  }

  public TerminologyMetadata addSynonymItem(String synonymItem) {
    if (this.synonym == null) {
      this.synonym = new LinkedHashSet<>();
    }
    this.synonym.add(synonymItem);
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return synonym
  **/
  @javax.annotation.Nullable
  public Set<String> getSynonym() {
    return synonym;
  }


  public void setSynonym(Set<String> synonym) {
    this.synonym = synonym;
  }


  public TerminologyMetadata synonymTermType(String synonymTermType) {
    
    this.synonymTermType = synonymTermType;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return synonymTermType
  **/
  @javax.annotation.Nullable
  public String getSynonymTermType() {
    return synonymTermType;
  }


  public void setSynonymTermType(String synonymTermType) {
    this.synonymTermType = synonymTermType;
  }


  public TerminologyMetadata synonymSource(String synonymSource) {
    
    this.synonymSource = synonymSource;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return synonymSource
  **/
  @javax.annotation.Nullable
  public String getSynonymSource() {
    return synonymSource;
  }


  public void setSynonymSource(String synonymSource) {
    this.synonymSource = synonymSource;
  }


  public TerminologyMetadata synonymCode(String synonymCode) {
    
    this.synonymCode = synonymCode;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return synonymCode
  **/
  @javax.annotation.Nullable
  public String getSynonymCode() {
    return synonymCode;
  }


  public void setSynonymCode(String synonymCode) {
    this.synonymCode = synonymCode;
  }


  public TerminologyMetadata synonymSubSource(String synonymSubSource) {
    
    this.synonymSubSource = synonymSubSource;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return synonymSubSource
  **/
  @javax.annotation.Nullable
  public String getSynonymSubSource() {
    return synonymSubSource;
  }


  public void setSynonymSubSource(String synonymSubSource) {
    this.synonymSubSource = synonymSubSource;
  }


  public TerminologyMetadata definition(Set<String> definition) {
    
    this.definition = definition;
    return this;
  }

  public TerminologyMetadata addDefinitionItem(String definitionItem) {
    if (this.definition == null) {
      this.definition = new LinkedHashSet<>();
    }
    this.definition.add(definitionItem);
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return definition
  **/
  @javax.annotation.Nullable
  public Set<String> getDefinition() {
    return definition;
  }


  public void setDefinition(Set<String> definition) {
    this.definition = definition;
  }


  public TerminologyMetadata definitionSource(String definitionSource) {
    
    this.definitionSource = definitionSource;
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return definitionSource
  **/
  @javax.annotation.Nullable
  public String getDefinitionSource() {
    return definitionSource;
  }


  public void setDefinitionSource(String definitionSource) {
    this.definitionSource = definitionSource;
  }


  public TerminologyMetadata mapRelation(String mapRelation) {
    
    this.mapRelation = mapRelation;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapRelation
  **/
  @javax.annotation.Nullable
  public String getMapRelation() {
    return mapRelation;
  }


  public void setMapRelation(String mapRelation) {
    this.mapRelation = mapRelation;
  }


  public TerminologyMetadata map(String map) {
    
    this.map = map;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return map
  **/
  @javax.annotation.Nullable
  public String getMap() {
    return map;
  }


  public void setMap(String map) {
    this.map = map;
  }


  public TerminologyMetadata mapTarget(String mapTarget) {
    
    this.mapTarget = mapTarget;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapTarget
  **/
  @javax.annotation.Nullable
  public String getMapTarget() {
    return mapTarget;
  }


  public void setMapTarget(String mapTarget) {
    this.mapTarget = mapTarget;
  }


  public TerminologyMetadata mapTargetTermType(String mapTargetTermType) {
    
    this.mapTargetTermType = mapTargetTermType;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapTargetTermType
  **/
  @javax.annotation.Nullable
  public String getMapTargetTermType() {
    return mapTargetTermType;
  }


  public void setMapTargetTermType(String mapTargetTermType) {
    this.mapTargetTermType = mapTargetTermType;
  }


  public TerminologyMetadata mapTargetTerminology(String mapTargetTerminology) {
    
    this.mapTargetTerminology = mapTargetTerminology;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapTargetTerminology
  **/
  @javax.annotation.Nullable
  public String getMapTargetTerminology() {
    return mapTargetTerminology;
  }


  public void setMapTargetTerminology(String mapTargetTerminology) {
    this.mapTargetTerminology = mapTargetTerminology;
  }


  public TerminologyMetadata mapTargetTerminologyVersion(String mapTargetTerminologyVersion) {
    
    this.mapTargetTerminologyVersion = mapTargetTerminologyVersion;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapTargetTerminologyVersion
  **/
  @javax.annotation.Nullable
  public String getMapTargetTerminologyVersion() {
    return mapTargetTerminologyVersion;
  }


  public void setMapTargetTerminologyVersion(String mapTargetTerminologyVersion) {
    this.mapTargetTerminologyVersion = mapTargetTerminologyVersion;
  }


  public TerminologyMetadata detailsColumns(Map<String, Boolean> detailsColumns) {
    
    this.detailsColumns = detailsColumns;
    return this;
  }

  public TerminologyMetadata putDetailsColumnsItem(String key, Boolean detailsColumnsItem) {
    if (this.detailsColumns == null) {
      this.detailsColumns = new HashMap<>();
    }
    this.detailsColumns.put(key, detailsColumnsItem);
    return this;
  }

   /**
   * Metadata for displaying concept
   * @return detailsColumns
  **/
  @javax.annotation.Nullable
  public Map<String, Boolean> getDetailsColumns() {
    return detailsColumns;
  }


  public void setDetailsColumns(Map<String, Boolean> detailsColumns) {
    this.detailsColumns = detailsColumns;
  }


  public TerminologyMetadata hierarchy(Boolean hierarchy) {
    
    this.hierarchy = hierarchy;
    return this;
  }

   /**
   * Indicates whether or not the terminology has a hierarchy
   * @return hierarchy
  **/
  @javax.annotation.Nullable
  public Boolean getHierarchy() {
    return hierarchy;
  }


  public void setHierarchy(Boolean hierarchy) {
    this.hierarchy = hierarchy;
  }


  public TerminologyMetadata history(Boolean history) {
    
    this.history = history;
    return this;
  }

   /**
   * Indicates whether or not the terminology has history records
   * @return history
  **/
  @javax.annotation.Nullable
  public Boolean getHistory() {
    return history;
  }


  public void setHistory(Boolean history) {
    this.history = history;
  }


  public TerminologyMetadata sourceCt(Integer sourceCt) {
    
    this.sourceCt = sourceCt;
    return this;
  }

   /**
   * Count of included sources
   * @return sourceCt
  **/
  @javax.annotation.Nullable
  public Integer getSourceCt() {
    return sourceCt;
  }


  public void setSourceCt(Integer sourceCt) {
    this.sourceCt = sourceCt;
  }


  public TerminologyMetadata termTypes(Map<String, String> termTypes) {
    
    this.termTypes = termTypes;
    return this;
  }

  public TerminologyMetadata putTermTypesItem(String key, String termTypesItem) {
    if (this.termTypes == null) {
      this.termTypes = new HashMap<>();
    }
    this.termTypes.put(key, termTypesItem);
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return termTypes
  **/
  @javax.annotation.Nullable
  public Map<String, String> getTermTypes() {
    return termTypes;
  }


  public void setTermTypes(Map<String, String> termTypes) {
    this.termTypes = termTypes;
  }


  public TerminologyMetadata subsetLink(String subsetLink) {
    
    this.subsetLink = subsetLink;
    return this;
  }

   /**
   * Metadata for downloading a subset
   * @return subsetLink
  **/
  @javax.annotation.Nullable
  public String getSubsetLink() {
    return subsetLink;
  }


  public void setSubsetLink(String subsetLink) {
    this.subsetLink = subsetLink;
  }


  public TerminologyMetadata subset(Set<String> subset) {
    
    this.subset = subset;
    return this;
  }

  public TerminologyMetadata addSubsetItem(String subsetItem) {
    if (this.subset == null) {
      this.subset = new LinkedHashSet<>();
    }
    this.subset.add(subsetItem);
    return this;
  }

   /**
   * OWL property metadata for building subsets
   * @return subset
  **/
  @javax.annotation.Nullable
  public Set<String> getSubset() {
    return subset;
  }


  public void setSubset(Set<String> subset) {
    this.subset = subset;
  }


  public TerminologyMetadata licenseText(String licenseText) {
    
    this.licenseText = licenseText;
    return this;
  }

   /**
   * License text for the UI
   * @return licenseText
  **/
  @javax.annotation.Nullable
  public String getLicenseText() {
    return licenseText;
  }


  public void setLicenseText(String licenseText) {
    this.licenseText = licenseText;
  }


  public TerminologyMetadata metaConceptField(String metaConceptField) {
    
    this.metaConceptField = metaConceptField;
    return this;
  }

   /**
   * Metadata for concept display
   * @return metaConceptField
  **/
  @javax.annotation.Nullable
  public String getMetaConceptField() {
    return metaConceptField;
  }


  public void setMetaConceptField(String metaConceptField) {
    this.metaConceptField = metaConceptField;
  }


  public TerminologyMetadata preferredTermTypes(List<String> preferredTermTypes) {
    
    this.preferredTermTypes = preferredTermTypes;
    return this;
  }

  public TerminologyMetadata addPreferredTermTypesItem(String preferredTermTypesItem) {
    if (this.preferredTermTypes == null) {
      this.preferredTermTypes = new ArrayList<>();
    }
    this.preferredTermTypes.add(preferredTermTypesItem);
    return this;
  }

   /**
   * OWL property metadata for building concept
   * @return preferredTermTypes
  **/
  @javax.annotation.Nullable
  public List<String> getPreferredTermTypes() {
    return preferredTermTypes;
  }


  public void setPreferredTermTypes(List<String> preferredTermTypes) {
    this.preferredTermTypes = preferredTermTypes;
  }


  public TerminologyMetadata codeLabel(String codeLabel) {
    
    this.codeLabel = codeLabel;
    return this;
  }

   /**
   * Metadata for concept display
   * @return codeLabel
  **/
  @javax.annotation.Nullable
  public String getCodeLabel() {
    return codeLabel;
  }


  public void setCodeLabel(String codeLabel) {
    this.codeLabel = codeLabel;
  }


  public TerminologyMetadata welcomeText(String welcomeText) {
    
    this.welcomeText = welcomeText;
    return this;
  }

   /**
   * Metadata for landing page welcome text
   * @return welcomeText
  **/
  @javax.annotation.Nullable
  public String getWelcomeText() {
    return welcomeText;
  }


  public void setWelcomeText(String welcomeText) {
    this.welcomeText = welcomeText;
  }


  public TerminologyMetadata synonymTermGroup(String synonymTermGroup) {
    
    this.synonymTermGroup = synonymTermGroup;
    return this;
  }

   /**
   * Get synonymTermGroup
   * @return synonymTermGroup
  **/
  @javax.annotation.Nullable
  public String getSynonymTermGroup() {
    return synonymTermGroup;
  }


  public void setSynonymTermGroup(String synonymTermGroup) {
    this.synonymTermGroup = synonymTermGroup;
  }


  public TerminologyMetadata mapTargetTermGroup(String mapTargetTermGroup) {
    
    this.mapTargetTermGroup = mapTargetTermGroup;
    return this;
  }

   /**
   * OWL property metadata for building maps
   * @return mapTargetTermGroup
  **/
  @javax.annotation.Nullable
  public String getMapTargetTermGroup() {
    return mapTargetTermGroup;
  }


  public void setMapTargetTermGroup(String mapTargetTermGroup) {
    this.mapTargetTermGroup = mapTargetTermGroup;
  }


  public TerminologyMetadata termGroups(Map<String, String> termGroups) {
    
    this.termGroups = termGroups;
    return this;
  }

  public TerminologyMetadata putTermGroupsItem(String key, String termGroupsItem) {
    if (this.termGroups == null) {
      this.termGroups = new HashMap<>();
    }
    this.termGroups.put(key, termGroupsItem);
    return this;
  }

   /**
   * Get termGroups
   * @return termGroups
  **/
  @javax.annotation.Nullable
  public Map<String, String> getTermGroups() {
    return termGroups;
  }


  public void setTermGroups(Map<String, String> termGroups) {
    this.termGroups = termGroups;
  }


  public TerminologyMetadata preferredTermGroups(List<String> preferredTermGroups) {
    
    this.preferredTermGroups = preferredTermGroups;
    return this;
  }

  public TerminologyMetadata addPreferredTermGroupsItem(String preferredTermGroupsItem) {
    if (this.preferredTermGroups == null) {
      this.preferredTermGroups = new ArrayList<>();
    }
    this.preferredTermGroups.add(preferredTermGroupsItem);
    return this;
  }

   /**
   * Get preferredTermGroups
   * @return preferredTermGroups
  **/
  @javax.annotation.Nullable
  public List<String> getPreferredTermGroups() {
    return preferredTermGroups;
  }


  public void setPreferredTermGroups(List<String> preferredTermGroups) {
    this.preferredTermGroups = preferredTermGroups;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TerminologyMetadata terminologyMetadata = (TerminologyMetadata) o;
    return Objects.equals(this.uri, terminologyMetadata.uri) &&
        Objects.equals(this.ct, terminologyMetadata.ct) &&
        Objects.equals(this.uiLabel, terminologyMetadata.uiLabel) &&
        Objects.equals(this.maxVersions, terminologyMetadata.maxVersions) &&
        Objects.equals(this.loader, terminologyMetadata.loader) &&
        Objects.equals(this.code, terminologyMetadata.code) &&
        Objects.equals(this.conceptStatus, terminologyMetadata.conceptStatus) &&
        Objects.equals(this.conceptStatuses, terminologyMetadata.conceptStatuses) &&
        Objects.equals(this.retiredStatusValue, terminologyMetadata.retiredStatusValue) &&
        Objects.equals(this.preferredName, terminologyMetadata.preferredName) &&
        Objects.equals(this.relationshipToTarget, terminologyMetadata.relationshipToTarget) &&
        Objects.equals(this.synonym, terminologyMetadata.synonym) &&
        Objects.equals(this.synonymTermType, terminologyMetadata.synonymTermType) &&
        Objects.equals(this.synonymSource, terminologyMetadata.synonymSource) &&
        Objects.equals(this.synonymCode, terminologyMetadata.synonymCode) &&
        Objects.equals(this.synonymSubSource, terminologyMetadata.synonymSubSource) &&
        Objects.equals(this.definition, terminologyMetadata.definition) &&
        Objects.equals(this.definitionSource, terminologyMetadata.definitionSource) &&
        Objects.equals(this.mapRelation, terminologyMetadata.mapRelation) &&
        Objects.equals(this.map, terminologyMetadata.map) &&
        Objects.equals(this.mapTarget, terminologyMetadata.mapTarget) &&
        Objects.equals(this.mapTargetTermType, terminologyMetadata.mapTargetTermType) &&
        Objects.equals(this.mapTargetTerminology, terminologyMetadata.mapTargetTerminology) &&
        Objects.equals(this.mapTargetTerminologyVersion, terminologyMetadata.mapTargetTerminologyVersion) &&
        Objects.equals(this.detailsColumns, terminologyMetadata.detailsColumns) &&
        Objects.equals(this.hierarchy, terminologyMetadata.hierarchy) &&
        Objects.equals(this.history, terminologyMetadata.history) &&
        Objects.equals(this.sourceCt, terminologyMetadata.sourceCt) &&
        Objects.equals(this.termTypes, terminologyMetadata.termTypes) &&
        Objects.equals(this.subsetLink, terminologyMetadata.subsetLink) &&
        Objects.equals(this.subset, terminologyMetadata.subset) &&
        Objects.equals(this.licenseText, terminologyMetadata.licenseText) &&
        Objects.equals(this.metaConceptField, terminologyMetadata.metaConceptField) &&
        Objects.equals(this.preferredTermTypes, terminologyMetadata.preferredTermTypes) &&
        Objects.equals(this.codeLabel, terminologyMetadata.codeLabel) &&
        Objects.equals(this.welcomeText, terminologyMetadata.welcomeText) &&
        Objects.equals(this.synonymTermGroup, terminologyMetadata.synonymTermGroup) &&
        Objects.equals(this.mapTargetTermGroup, terminologyMetadata.mapTargetTermGroup) &&
        Objects.equals(this.termGroups, terminologyMetadata.termGroups) &&
        Objects.equals(this.preferredTermGroups, terminologyMetadata.preferredTermGroups);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, ct, uiLabel, maxVersions, loader, code, conceptStatus, conceptStatuses, retiredStatusValue, preferredName, relationshipToTarget, synonym, synonymTermType, synonymSource, synonymCode, synonymSubSource, definition, definitionSource, mapRelation, map, mapTarget, mapTargetTermType, mapTargetTerminology, mapTargetTerminologyVersion, detailsColumns, hierarchy, history, sourceCt, termTypes, subsetLink, subset, licenseText, metaConceptField, preferredTermTypes, codeLabel, welcomeText, synonymTermGroup, mapTargetTermGroup, termGroups, preferredTermGroups);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TerminologyMetadata {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    ct: ").append(toIndentedString(ct)).append("\n");
    sb.append("    uiLabel: ").append(toIndentedString(uiLabel)).append("\n");
    sb.append("    maxVersions: ").append(toIndentedString(maxVersions)).append("\n");
    sb.append("    loader: ").append(toIndentedString(loader)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    conceptStatus: ").append(toIndentedString(conceptStatus)).append("\n");
    sb.append("    conceptStatuses: ").append(toIndentedString(conceptStatuses)).append("\n");
    sb.append("    retiredStatusValue: ").append(toIndentedString(retiredStatusValue)).append("\n");
    sb.append("    preferredName: ").append(toIndentedString(preferredName)).append("\n");
    sb.append("    relationshipToTarget: ").append(toIndentedString(relationshipToTarget)).append("\n");
    sb.append("    synonym: ").append(toIndentedString(synonym)).append("\n");
    sb.append("    synonymTermType: ").append(toIndentedString(synonymTermType)).append("\n");
    sb.append("    synonymSource: ").append(toIndentedString(synonymSource)).append("\n");
    sb.append("    synonymCode: ").append(toIndentedString(synonymCode)).append("\n");
    sb.append("    synonymSubSource: ").append(toIndentedString(synonymSubSource)).append("\n");
    sb.append("    definition: ").append(toIndentedString(definition)).append("\n");
    sb.append("    definitionSource: ").append(toIndentedString(definitionSource)).append("\n");
    sb.append("    mapRelation: ").append(toIndentedString(mapRelation)).append("\n");
    sb.append("    map: ").append(toIndentedString(map)).append("\n");
    sb.append("    mapTarget: ").append(toIndentedString(mapTarget)).append("\n");
    sb.append("    mapTargetTermType: ").append(toIndentedString(mapTargetTermType)).append("\n");
    sb.append("    mapTargetTerminology: ").append(toIndentedString(mapTargetTerminology)).append("\n");
    sb.append("    mapTargetTerminologyVersion: ").append(toIndentedString(mapTargetTerminologyVersion)).append("\n");
    sb.append("    detailsColumns: ").append(toIndentedString(detailsColumns)).append("\n");
    sb.append("    hierarchy: ").append(toIndentedString(hierarchy)).append("\n");
    sb.append("    history: ").append(toIndentedString(history)).append("\n");
    sb.append("    sourceCt: ").append(toIndentedString(sourceCt)).append("\n");
    sb.append("    termTypes: ").append(toIndentedString(termTypes)).append("\n");
    sb.append("    subsetLink: ").append(toIndentedString(subsetLink)).append("\n");
    sb.append("    subset: ").append(toIndentedString(subset)).append("\n");
    sb.append("    licenseText: ").append(toIndentedString(licenseText)).append("\n");
    sb.append("    metaConceptField: ").append(toIndentedString(metaConceptField)).append("\n");
    sb.append("    preferredTermTypes: ").append(toIndentedString(preferredTermTypes)).append("\n");
    sb.append("    codeLabel: ").append(toIndentedString(codeLabel)).append("\n");
    sb.append("    welcomeText: ").append(toIndentedString(welcomeText)).append("\n");
    sb.append("    synonymTermGroup: ").append(toIndentedString(synonymTermGroup)).append("\n");
    sb.append("    mapTargetTermGroup: ").append(toIndentedString(mapTargetTermGroup)).append("\n");
    sb.append("    termGroups: ").append(toIndentedString(termGroups)).append("\n");
    sb.append("    preferredTermGroups: ").append(toIndentedString(preferredTermGroups)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("uri");
    openapiFields.add("ct");
    openapiFields.add("uiLabel");
    openapiFields.add("maxVersions");
    openapiFields.add("loader");
    openapiFields.add("code");
    openapiFields.add("conceptStatus");
    openapiFields.add("conceptStatuses");
    openapiFields.add("retiredStatusValue");
    openapiFields.add("preferredName");
    openapiFields.add("relationshipToTarget");
    openapiFields.add("synonym");
    openapiFields.add("synonymTermType");
    openapiFields.add("synonymSource");
    openapiFields.add("synonymCode");
    openapiFields.add("synonymSubSource");
    openapiFields.add("definition");
    openapiFields.add("definitionSource");
    openapiFields.add("mapRelation");
    openapiFields.add("map");
    openapiFields.add("mapTarget");
    openapiFields.add("mapTargetTermType");
    openapiFields.add("mapTargetTerminology");
    openapiFields.add("mapTargetTerminologyVersion");
    openapiFields.add("detailsColumns");
    openapiFields.add("hierarchy");
    openapiFields.add("history");
    openapiFields.add("sourceCt");
    openapiFields.add("termTypes");
    openapiFields.add("subsetLink");
    openapiFields.add("subset");
    openapiFields.add("licenseText");
    openapiFields.add("metaConceptField");
    openapiFields.add("preferredTermTypes");
    openapiFields.add("codeLabel");
    openapiFields.add("welcomeText");
    openapiFields.add("synonymTermGroup");
    openapiFields.add("mapTargetTermGroup");
    openapiFields.add("termGroups");
    openapiFields.add("preferredTermGroups");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TerminologyMetadata
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TerminologyMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TerminologyMetadata is not found in the empty JSON string", TerminologyMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TerminologyMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TerminologyMetadata` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) && !jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      if ((jsonObj.get("uiLabel") != null && !jsonObj.get("uiLabel").isJsonNull()) && !jsonObj.get("uiLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uiLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uiLabel").toString()));
      }
      if ((jsonObj.get("loader") != null && !jsonObj.get("loader").isJsonNull()) && !jsonObj.get("loader").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loader` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loader").toString()));
      }
      if ((jsonObj.get("code") != null && !jsonObj.get("code").isJsonNull()) && !jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      if ((jsonObj.get("conceptStatus") != null && !jsonObj.get("conceptStatus").isJsonNull()) && !jsonObj.get("conceptStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conceptStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conceptStatus").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conceptStatuses") != null && !jsonObj.get("conceptStatuses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conceptStatuses` to be an array in the JSON string but got `%s`", jsonObj.get("conceptStatuses").toString()));
      }
      if ((jsonObj.get("retiredStatusValue") != null && !jsonObj.get("retiredStatusValue").isJsonNull()) && !jsonObj.get("retiredStatusValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retiredStatusValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retiredStatusValue").toString()));
      }
      if ((jsonObj.get("preferredName") != null && !jsonObj.get("preferredName").isJsonNull()) && !jsonObj.get("preferredName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preferredName").toString()));
      }
      if ((jsonObj.get("relationshipToTarget") != null && !jsonObj.get("relationshipToTarget").isJsonNull()) && !jsonObj.get("relationshipToTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `relationshipToTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("relationshipToTarget").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("synonym") != null && !jsonObj.get("synonym").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonym` to be an array in the JSON string but got `%s`", jsonObj.get("synonym").toString()));
      }
      if ((jsonObj.get("synonymTermType") != null && !jsonObj.get("synonymTermType").isJsonNull()) && !jsonObj.get("synonymTermType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymTermType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymTermType").toString()));
      }
      if ((jsonObj.get("synonymSource") != null && !jsonObj.get("synonymSource").isJsonNull()) && !jsonObj.get("synonymSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymSource").toString()));
      }
      if ((jsonObj.get("synonymCode") != null && !jsonObj.get("synonymCode").isJsonNull()) && !jsonObj.get("synonymCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymCode").toString()));
      }
      if ((jsonObj.get("synonymSubSource") != null && !jsonObj.get("synonymSubSource").isJsonNull()) && !jsonObj.get("synonymSubSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymSubSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymSubSource").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("definition") != null && !jsonObj.get("definition").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `definition` to be an array in the JSON string but got `%s`", jsonObj.get("definition").toString()));
      }
      if ((jsonObj.get("definitionSource") != null && !jsonObj.get("definitionSource").isJsonNull()) && !jsonObj.get("definitionSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definitionSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definitionSource").toString()));
      }
      if ((jsonObj.get("mapRelation") != null && !jsonObj.get("mapRelation").isJsonNull()) && !jsonObj.get("mapRelation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapRelation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapRelation").toString()));
      }
      if ((jsonObj.get("map") != null && !jsonObj.get("map").isJsonNull()) && !jsonObj.get("map").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `map` to be a primitive type in the JSON string but got `%s`", jsonObj.get("map").toString()));
      }
      if ((jsonObj.get("mapTarget") != null && !jsonObj.get("mapTarget").isJsonNull()) && !jsonObj.get("mapTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTarget").toString()));
      }
      if ((jsonObj.get("mapTargetTermType") != null && !jsonObj.get("mapTargetTermType").isJsonNull()) && !jsonObj.get("mapTargetTermType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTermType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTermType").toString()));
      }
      if ((jsonObj.get("mapTargetTerminology") != null && !jsonObj.get("mapTargetTerminology").isJsonNull()) && !jsonObj.get("mapTargetTerminology").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTerminology` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTerminology").toString()));
      }
      if ((jsonObj.get("mapTargetTerminologyVersion") != null && !jsonObj.get("mapTargetTerminologyVersion").isJsonNull()) && !jsonObj.get("mapTargetTerminologyVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTerminologyVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTerminologyVersion").toString()));
      }
      if ((jsonObj.get("subsetLink") != null && !jsonObj.get("subsetLink").isJsonNull()) && !jsonObj.get("subsetLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subsetLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subsetLink").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subset") != null && !jsonObj.get("subset").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subset` to be an array in the JSON string but got `%s`", jsonObj.get("subset").toString()));
      }
      if ((jsonObj.get("licenseText") != null && !jsonObj.get("licenseText").isJsonNull()) && !jsonObj.get("licenseText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenseText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("licenseText").toString()));
      }
      if ((jsonObj.get("metaConceptField") != null && !jsonObj.get("metaConceptField").isJsonNull()) && !jsonObj.get("metaConceptField").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metaConceptField` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metaConceptField").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preferredTermTypes") != null && !jsonObj.get("preferredTermTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredTermTypes` to be an array in the JSON string but got `%s`", jsonObj.get("preferredTermTypes").toString()));
      }
      if ((jsonObj.get("codeLabel") != null && !jsonObj.get("codeLabel").isJsonNull()) && !jsonObj.get("codeLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `codeLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("codeLabel").toString()));
      }
      if ((jsonObj.get("welcomeText") != null && !jsonObj.get("welcomeText").isJsonNull()) && !jsonObj.get("welcomeText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `welcomeText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("welcomeText").toString()));
      }
      if ((jsonObj.get("synonymTermGroup") != null && !jsonObj.get("synonymTermGroup").isJsonNull()) && !jsonObj.get("synonymTermGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `synonymTermGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("synonymTermGroup").toString()));
      }
      if ((jsonObj.get("mapTargetTermGroup") != null && !jsonObj.get("mapTargetTermGroup").isJsonNull()) && !jsonObj.get("mapTargetTermGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapTargetTermGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapTargetTermGroup").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preferredTermGroups") != null && !jsonObj.get("preferredTermGroups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredTermGroups` to be an array in the JSON string but got `%s`", jsonObj.get("preferredTermGroups").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TerminologyMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TerminologyMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TerminologyMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TerminologyMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<TerminologyMetadata>() {
           @Override
           public void write(JsonWriter out, TerminologyMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TerminologyMetadata read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TerminologyMetadata given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TerminologyMetadata
  * @throws IOException if the JSON string is invalid with respect to TerminologyMetadata
  */
  public static TerminologyMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TerminologyMetadata.class);
  }

 /**
  * Convert an instance of TerminologyMetadata to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


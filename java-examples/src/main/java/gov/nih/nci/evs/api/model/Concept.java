/*
 * NCI EVS Rest API
 * Endpoints to support searching, metadata, and content retrieval for EVS terminologies. To learn more about how to interact with this api, see the <a href=\"https://github.com/NCIEVS/evsrestapi-client-SDK\">Github evsrestapi-client-SDK project.</a>
 *
 * The version of the OpenAPI document: 1.7.2.RELEASE
 * Contact: NCIAppSupport@nih.gov
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package gov.nih.nci.evs.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import gov.nih.nci.evs.api.model.Association;
import gov.nih.nci.evs.api.model.ConceptMap;
import gov.nih.nci.evs.api.model.Definition;
import gov.nih.nci.evs.api.model.DisjointWith;
import gov.nih.nci.evs.api.model.History;
import gov.nih.nci.evs.api.model.Paths;
import gov.nih.nci.evs.api.model.Property;
import gov.nih.nci.evs.api.model.Role;
import gov.nih.nci.evs.api.model.Synonym;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import gov.nih.nci.evs.api.invoker.JSON;

/**
 * Represents a concept in a terminology
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-17T17:06:13.350753-07:00[America/Los_Angeles]", comments = "Generator version: 7.5.0")
public class Concept {
  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  private String uri;

  public static final String SERIALIZED_NAME_CT = "ct";
  @SerializedName(SERIALIZED_NAME_CT)
  private Integer ct;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_TERMINOLOGY = "terminology";
  @SerializedName(SERIALIZED_NAME_TERMINOLOGY)
  private String terminology;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_LEVEL = "level";
  @SerializedName(SERIALIZED_NAME_LEVEL)
  private Integer level;

  public static final String SERIALIZED_NAME_HIGHLIGHT = "highlight";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT)
  private String highlight;

  public static final String SERIALIZED_NAME_SUBSET_LINK = "subsetLink";
  @SerializedName(SERIALIZED_NAME_SUBSET_LINK)
  private String subsetLink;

  public static final String SERIALIZED_NAME_MAPSET_LINK = "mapsetLink";
  @SerializedName(SERIALIZED_NAME_MAPSET_LINK)
  private String mapsetLink;

  public static final String SERIALIZED_NAME_CONCEPT_STATUS = "conceptStatus";
  @SerializedName(SERIALIZED_NAME_CONCEPT_STATUS)
  private String conceptStatus;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_LEAF = "leaf";
  @SerializedName(SERIALIZED_NAME_LEAF)
  private Boolean leaf;

  public static final String SERIALIZED_NAME_ACTIVE = "active";
  @SerializedName(SERIALIZED_NAME_ACTIVE)
  private Boolean active;

  public static final String SERIALIZED_NAME_SYNONYMS = "synonyms";
  @SerializedName(SERIALIZED_NAME_SYNONYMS)
  private List<Synonym> synonyms = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEFINITIONS = "definitions";
  @SerializedName(SERIALIZED_NAME_DEFINITIONS)
  private List<Definition> definitions = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private List<Property> properties = new ArrayList<>();

  public static final String SERIALIZED_NAME_CHILDREN = "children";
  @SerializedName(SERIALIZED_NAME_CHILDREN)
  private List<Concept> children = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARENTS = "parents";
  @SerializedName(SERIALIZED_NAME_PARENTS)
  private List<Concept> parents = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESCENDANTS = "descendants";
  @SerializedName(SERIALIZED_NAME_DESCENDANTS)
  private List<Concept> descendants = new ArrayList<>();

  public static final String SERIALIZED_NAME_ASSOCIATIONS = "associations";
  @SerializedName(SERIALIZED_NAME_ASSOCIATIONS)
  private List<Association> associations = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVERSE_ASSOCIATIONS = "inverseAssociations";
  @SerializedName(SERIALIZED_NAME_INVERSE_ASSOCIATIONS)
  private List<Association> inverseAssociations = new ArrayList<>();

  public static final String SERIALIZED_NAME_ROLES = "roles";
  @SerializedName(SERIALIZED_NAME_ROLES)
  private List<Role> roles = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISJOINT_WITH = "disjointWith";
  @SerializedName(SERIALIZED_NAME_DISJOINT_WITH)
  private List<DisjointWith> disjointWith = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVERSE_ROLES = "inverseRoles";
  @SerializedName(SERIALIZED_NAME_INVERSE_ROLES)
  private List<Role> inverseRoles = new ArrayList<>();

  public static final String SERIALIZED_NAME_HISTORY = "history";
  @SerializedName(SERIALIZED_NAME_HISTORY)
  private List<History> history = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAPS = "maps";
  @SerializedName(SERIALIZED_NAME_MAPS)
  private List<ConceptMap> maps = new ArrayList<>();

  public static final String SERIALIZED_NAME_PATHS = "paths";
  @SerializedName(SERIALIZED_NAME_PATHS)
  private Paths paths;

  public Concept() {
  }

  public Concept uri(String uri) {
    this.uri = uri;
    return this;
  }

   /**
   * URI for this element in an rdf-based source file
   * @return uri
  **/
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }

  public void setUri(String uri) {
    this.uri = uri;
  }


  public Concept ct(Integer ct) {
    this.ct = ct;
    return this;
  }

   /**
   * Used to indicate the total amount of data in cases where a limit is being applied
   * @return ct
  **/
  @javax.annotation.Nullable
  public Integer getCt() {
    return ct;
  }

  public void setCt(Integer ct) {
    this.ct = ct;
  }


  public Concept code(String code) {
    this.code = code;
    return this;
  }

   /**
   * Code (unique identifier) for this meaning
   * @return code
  **/
  @javax.annotation.Nullable
  public String getCode() {
    return code;
  }

  public void setCode(String code) {
    this.code = code;
  }


  public Concept name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Preferred name for the code
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Concept terminology(String terminology) {
    this.terminology = terminology;
    return this;
  }

   /**
   * Terminology abbreviation, e.g. &#39;nci&#39;
   * @return terminology
  **/
  @javax.annotation.Nullable
  public String getTerminology() {
    return terminology;
  }

  public void setTerminology(String terminology) {
    this.terminology = terminology;
  }


  public Concept version(String version) {
    this.version = version;
    return this;
  }

   /**
   * Terminology version, e.g. &#39;23.11d&#39;
   * @return version
  **/
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public Concept level(Integer level) {
    this.level = level;
    return this;
  }

   /**
   * Level of depth in a hierarchy (when this object is used to represent an element in a path)
   * @return level
  **/
  @javax.annotation.Nullable
  public Integer getLevel() {
    return level;
  }

  public void setLevel(Integer level) {
    this.level = level;
  }


  public Concept highlight(String highlight) {
    this.highlight = highlight;
    return this;
  }

   /**
   * Used by search calls to provide information for highlighting a view of results
   * @return highlight
  **/
  @javax.annotation.Nullable
  public String getHighlight() {
    return highlight;
  }

  public void setHighlight(String highlight) {
    this.highlight = highlight;
  }


  public Concept subsetLink(String subsetLink) {
    this.subsetLink = subsetLink;
    return this;
  }

   /**
   * Link to download data for a subset, used when the concept represents subset metadata
   * @return subsetLink
  **/
  @javax.annotation.Nullable
  public String getSubsetLink() {
    return subsetLink;
  }

  public void setSubsetLink(String subsetLink) {
    this.subsetLink = subsetLink;
  }


  public Concept mapsetLink(String mapsetLink) {
    this.mapsetLink = mapsetLink;
    return this;
  }

   /**
   * Metadata for downloading a mapset
   * @return mapsetLink
  **/
  @javax.annotation.Nullable
  public String getMapsetLink() {
    return mapsetLink;
  }

  public void setMapsetLink(String mapsetLink) {
    this.mapsetLink = mapsetLink;
  }


  public Concept conceptStatus(String conceptStatus) {
    this.conceptStatus = conceptStatus;
    return this;
  }

   /**
   * Status value for the concept, e.g. Retired_Concept
   * @return conceptStatus
  **/
  @javax.annotation.Nullable
  public String getConceptStatus() {
    return conceptStatus;
  }

  public void setConceptStatus(String conceptStatus) {
    this.conceptStatus = conceptStatus;
  }


  public Concept source(String source) {
    this.source = source;
    return this;
  }

   /**
   * Associations from this concept to other ones
   * @return source
  **/
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public Concept leaf(Boolean leaf) {
    this.leaf = leaf;
    return this;
  }

   /**
   * Indicates whether concept is a leaf node
   * @return leaf
  **/
  @javax.annotation.Nullable
  public Boolean getLeaf() {
    return leaf;
  }

  public void setLeaf(Boolean leaf) {
    this.leaf = leaf;
  }


  public Concept active(Boolean active) {
    this.active = active;
    return this;
  }

   /**
   * Indicates whether the concept is active
   * @return active
  **/
  @javax.annotation.Nullable
  public Boolean getActive() {
    return active;
  }

  public void setActive(Boolean active) {
    this.active = active;
  }


  public Concept synonyms(List<Synonym> synonyms) {
    this.synonyms = synonyms;
    return this;
  }

  public Concept addSynonymsItem(Synonym synonymsItem) {
    if (this.synonyms == null) {
      this.synonyms = new ArrayList<>();
    }
    this.synonyms.add(synonymsItem);
    return this;
  }

   /**
   * Synonyms, or all of the names for this concept, including the preferred name
   * @return synonyms
  **/
  @javax.annotation.Nullable
  public List<Synonym> getSynonyms() {
    return synonyms;
  }

  public void setSynonyms(List<Synonym> synonyms) {
    this.synonyms = synonyms;
  }


  public Concept definitions(List<Definition> definitions) {
    this.definitions = definitions;
    return this;
  }

  public Concept addDefinitionsItem(Definition definitionsItem) {
    if (this.definitions == null) {
      this.definitions = new ArrayList<>();
    }
    this.definitions.add(definitionsItem);
    return this;
  }

   /**
   * Text definitions
   * @return definitions
  **/
  @javax.annotation.Nullable
  public List<Definition> getDefinitions() {
    return definitions;
  }

  public void setDefinitions(List<Definition> definitions) {
    this.definitions = definitions;
  }


  public Concept properties(List<Property> properties) {
    this.properties = properties;
    return this;
  }

  public Concept addPropertiesItem(Property propertiesItem) {
    if (this.properties == null) {
      this.properties = new ArrayList<>();
    }
    this.properties.add(propertiesItem);
    return this;
  }

   /**
   * Key/value properties
   * @return properties
  **/
  @javax.annotation.Nullable
  public List<Property> getProperties() {
    return properties;
  }

  public void setProperties(List<Property> properties) {
    this.properties = properties;
  }


  public Concept children(List<Concept> children) {
    this.children = children;
    return this;
  }

  public Concept addChildrenItem(Concept childrenItem) {
    if (this.children == null) {
      this.children = new ArrayList<>();
    }
    this.children.add(childrenItem);
    return this;
  }

   /**
   * Child concepts in the hierarchy
   * @return children
  **/
  @javax.annotation.Nullable
  public List<Concept> getChildren() {
    return children;
  }

  public void setChildren(List<Concept> children) {
    this.children = children;
  }


  public Concept parents(List<Concept> parents) {
    this.parents = parents;
    return this;
  }

  public Concept addParentsItem(Concept parentsItem) {
    if (this.parents == null) {
      this.parents = new ArrayList<>();
    }
    this.parents.add(parentsItem);
    return this;
  }

   /**
   * Parent concepts in the hierarchy
   * @return parents
  **/
  @javax.annotation.Nullable
  public List<Concept> getParents() {
    return parents;
  }

  public void setParents(List<Concept> parents) {
    this.parents = parents;
  }


  public Concept descendants(List<Concept> descendants) {
    this.descendants = descendants;
    return this;
  }

  public Concept addDescendantsItem(Concept descendantsItem) {
    if (this.descendants == null) {
      this.descendants = new ArrayList<>();
    }
    this.descendants.add(descendantsItem);
    return this;
  }

   /**
   * Descendant concepts in the hierarchy
   * @return descendants
  **/
  @javax.annotation.Nullable
  public List<Concept> getDescendants() {
    return descendants;
  }

  public void setDescendants(List<Concept> descendants) {
    this.descendants = descendants;
  }


  public Concept associations(List<Association> associations) {
    this.associations = associations;
    return this;
  }

  public Concept addAssociationsItem(Association associationsItem) {
    if (this.associations == null) {
      this.associations = new ArrayList<>();
    }
    this.associations.add(associationsItem);
    return this;
  }

   /**
   * Associations from this concept to other ones
   * @return associations
  **/
  @javax.annotation.Nullable
  public List<Association> getAssociations() {
    return associations;
  }

  public void setAssociations(List<Association> associations) {
    this.associations = associations;
  }


  public Concept inverseAssociations(List<Association> inverseAssociations) {
    this.inverseAssociations = inverseAssociations;
    return this;
  }

  public Concept addInverseAssociationsItem(Association inverseAssociationsItem) {
    if (this.inverseAssociations == null) {
      this.inverseAssociations = new ArrayList<>();
    }
    this.inverseAssociations.add(inverseAssociationsItem);
    return this;
  }

   /**
   * Associations to this concept from other ones
   * @return inverseAssociations
  **/
  @javax.annotation.Nullable
  public List<Association> getInverseAssociations() {
    return inverseAssociations;
  }

  public void setInverseAssociations(List<Association> inverseAssociations) {
    this.inverseAssociations = inverseAssociations;
  }


  public Concept roles(List<Role> roles) {
    this.roles = roles;
    return this;
  }

  public Concept addRolesItem(Role rolesItem) {
    if (this.roles == null) {
      this.roles = new ArrayList<>();
    }
    this.roles.add(rolesItem);
    return this;
  }

   /**
   * Roles from this concept to other ones
   * @return roles
  **/
  @javax.annotation.Nullable
  public List<Role> getRoles() {
    return roles;
  }

  public void setRoles(List<Role> roles) {
    this.roles = roles;
  }


  public Concept disjointWith(List<DisjointWith> disjointWith) {
    this.disjointWith = disjointWith;
    return this;
  }

  public Concept addDisjointWithItem(DisjointWith disjointWithItem) {
    if (this.disjointWith == null) {
      this.disjointWith = new ArrayList<>();
    }
    this.disjointWith.add(disjointWithItem);
    return this;
  }

   /**
   * Assertions of disjointness with respect to other concepts
   * @return disjointWith
  **/
  @javax.annotation.Nullable
  public List<DisjointWith> getDisjointWith() {
    return disjointWith;
  }

  public void setDisjointWith(List<DisjointWith> disjointWith) {
    this.disjointWith = disjointWith;
  }


  public Concept inverseRoles(List<Role> inverseRoles) {
    this.inverseRoles = inverseRoles;
    return this;
  }

  public Concept addInverseRolesItem(Role inverseRolesItem) {
    if (this.inverseRoles == null) {
      this.inverseRoles = new ArrayList<>();
    }
    this.inverseRoles.add(inverseRolesItem);
    return this;
  }

   /**
   * Roles to this concept from other ones
   * @return inverseRoles
  **/
  @javax.annotation.Nullable
  public List<Role> getInverseRoles() {
    return inverseRoles;
  }

  public void setInverseRoles(List<Role> inverseRoles) {
    this.inverseRoles = inverseRoles;
  }


  public Concept history(List<History> history) {
    this.history = history;
    return this;
  }

  public Concept addHistoryItem(History historyItem) {
    if (this.history == null) {
      this.history = new ArrayList<>();
    }
    this.history.add(historyItem);
    return this;
  }

   /**
   * History records
   * @return history
  **/
  @javax.annotation.Nullable
  public List<History> getHistory() {
    return history;
  }

  public void setHistory(List<History> history) {
    this.history = history;
  }


  public Concept maps(List<ConceptMap> maps) {
    this.maps = maps;
    return this;
  }

  public Concept addMapsItem(ConceptMap mapsItem) {
    if (this.maps == null) {
      this.maps = new ArrayList<>();
    }
    this.maps.add(mapsItem);
    return this;
  }

   /**
   * Maps from this concept to concepts in other terminologies
   * @return maps
  **/
  @javax.annotation.Nullable
  public List<ConceptMap> getMaps() {
    return maps;
  }

  public void setMaps(List<ConceptMap> maps) {
    this.maps = maps;
  }


  public Concept paths(Paths paths) {
    this.paths = paths;
    return this;
  }

   /**
   * Get paths
   * @return paths
  **/
  @javax.annotation.Nullable
  public Paths getPaths() {
    return paths;
  }

  public void setPaths(Paths paths) {
    this.paths = paths;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Concept concept = (Concept) o;
    return Objects.equals(this.uri, concept.uri) &&
        Objects.equals(this.ct, concept.ct) &&
        Objects.equals(this.code, concept.code) &&
        Objects.equals(this.name, concept.name) &&
        Objects.equals(this.terminology, concept.terminology) &&
        Objects.equals(this.version, concept.version) &&
        Objects.equals(this.level, concept.level) &&
        Objects.equals(this.highlight, concept.highlight) &&
        Objects.equals(this.subsetLink, concept.subsetLink) &&
        Objects.equals(this.mapsetLink, concept.mapsetLink) &&
        Objects.equals(this.conceptStatus, concept.conceptStatus) &&
        Objects.equals(this.source, concept.source) &&
        Objects.equals(this.leaf, concept.leaf) &&
        Objects.equals(this.active, concept.active) &&
        Objects.equals(this.synonyms, concept.synonyms) &&
        Objects.equals(this.definitions, concept.definitions) &&
        Objects.equals(this.properties, concept.properties) &&
        Objects.equals(this.children, concept.children) &&
        Objects.equals(this.parents, concept.parents) &&
        Objects.equals(this.descendants, concept.descendants) &&
        Objects.equals(this.associations, concept.associations) &&
        Objects.equals(this.inverseAssociations, concept.inverseAssociations) &&
        Objects.equals(this.roles, concept.roles) &&
        Objects.equals(this.disjointWith, concept.disjointWith) &&
        Objects.equals(this.inverseRoles, concept.inverseRoles) &&
        Objects.equals(this.history, concept.history) &&
        Objects.equals(this.maps, concept.maps) &&
        Objects.equals(this.paths, concept.paths);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, ct, code, name, terminology, version, level, highlight, subsetLink, mapsetLink, conceptStatus, source, leaf, active, synonyms, definitions, properties, children, parents, descendants, associations, inverseAssociations, roles, disjointWith, inverseRoles, history, maps, paths);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Concept {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    ct: ").append(toIndentedString(ct)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    terminology: ").append(toIndentedString(terminology)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    level: ").append(toIndentedString(level)).append("\n");
    sb.append("    highlight: ").append(toIndentedString(highlight)).append("\n");
    sb.append("    subsetLink: ").append(toIndentedString(subsetLink)).append("\n");
    sb.append("    mapsetLink: ").append(toIndentedString(mapsetLink)).append("\n");
    sb.append("    conceptStatus: ").append(toIndentedString(conceptStatus)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    leaf: ").append(toIndentedString(leaf)).append("\n");
    sb.append("    active: ").append(toIndentedString(active)).append("\n");
    sb.append("    synonyms: ").append(toIndentedString(synonyms)).append("\n");
    sb.append("    definitions: ").append(toIndentedString(definitions)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    children: ").append(toIndentedString(children)).append("\n");
    sb.append("    parents: ").append(toIndentedString(parents)).append("\n");
    sb.append("    descendants: ").append(toIndentedString(descendants)).append("\n");
    sb.append("    associations: ").append(toIndentedString(associations)).append("\n");
    sb.append("    inverseAssociations: ").append(toIndentedString(inverseAssociations)).append("\n");
    sb.append("    roles: ").append(toIndentedString(roles)).append("\n");
    sb.append("    disjointWith: ").append(toIndentedString(disjointWith)).append("\n");
    sb.append("    inverseRoles: ").append(toIndentedString(inverseRoles)).append("\n");
    sb.append("    history: ").append(toIndentedString(history)).append("\n");
    sb.append("    maps: ").append(toIndentedString(maps)).append("\n");
    sb.append("    paths: ").append(toIndentedString(paths)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("uri");
    openapiFields.add("ct");
    openapiFields.add("code");
    openapiFields.add("name");
    openapiFields.add("terminology");
    openapiFields.add("version");
    openapiFields.add("level");
    openapiFields.add("highlight");
    openapiFields.add("subsetLink");
    openapiFields.add("mapsetLink");
    openapiFields.add("conceptStatus");
    openapiFields.add("source");
    openapiFields.add("leaf");
    openapiFields.add("active");
    openapiFields.add("synonyms");
    openapiFields.add("definitions");
    openapiFields.add("properties");
    openapiFields.add("children");
    openapiFields.add("parents");
    openapiFields.add("descendants");
    openapiFields.add("associations");
    openapiFields.add("inverseAssociations");
    openapiFields.add("roles");
    openapiFields.add("disjointWith");
    openapiFields.add("inverseRoles");
    openapiFields.add("history");
    openapiFields.add("maps");
    openapiFields.add("paths");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Concept
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Concept.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Concept is not found in the empty JSON string", Concept.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Concept.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Concept` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) && !jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      if ((jsonObj.get("code") != null && !jsonObj.get("code").isJsonNull()) && !jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("terminology") != null && !jsonObj.get("terminology").isJsonNull()) && !jsonObj.get("terminology").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminology` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminology").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if ((jsonObj.get("highlight") != null && !jsonObj.get("highlight").isJsonNull()) && !jsonObj.get("highlight").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlight` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlight").toString()));
      }
      if ((jsonObj.get("subsetLink") != null && !jsonObj.get("subsetLink").isJsonNull()) && !jsonObj.get("subsetLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subsetLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subsetLink").toString()));
      }
      if ((jsonObj.get("mapsetLink") != null && !jsonObj.get("mapsetLink").isJsonNull()) && !jsonObj.get("mapsetLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapsetLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapsetLink").toString()));
      }
      if ((jsonObj.get("conceptStatus") != null && !jsonObj.get("conceptStatus").isJsonNull()) && !jsonObj.get("conceptStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conceptStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conceptStatus").toString()));
      }
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if (jsonObj.get("synonyms") != null && !jsonObj.get("synonyms").isJsonNull()) {
        JsonArray jsonArraysynonyms = jsonObj.getAsJsonArray("synonyms");
        if (jsonArraysynonyms != null) {
          // ensure the json data is an array
          if (!jsonObj.get("synonyms").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `synonyms` to be an array in the JSON string but got `%s`", jsonObj.get("synonyms").toString()));
          }

          // validate the optional field `synonyms` (array)
          for (int i = 0; i < jsonArraysynonyms.size(); i++) {
            Synonym.validateJsonElement(jsonArraysynonyms.get(i));
          };
        }
      }
      if (jsonObj.get("definitions") != null && !jsonObj.get("definitions").isJsonNull()) {
        JsonArray jsonArraydefinitions = jsonObj.getAsJsonArray("definitions");
        if (jsonArraydefinitions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("definitions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `definitions` to be an array in the JSON string but got `%s`", jsonObj.get("definitions").toString()));
          }

          // validate the optional field `definitions` (array)
          for (int i = 0; i < jsonArraydefinitions.size(); i++) {
            Definition.validateJsonElement(jsonArraydefinitions.get(i));
          };
        }
      }
      if (jsonObj.get("properties") != null && !jsonObj.get("properties").isJsonNull()) {
        JsonArray jsonArrayproperties = jsonObj.getAsJsonArray("properties");
        if (jsonArrayproperties != null) {
          // ensure the json data is an array
          if (!jsonObj.get("properties").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `properties` to be an array in the JSON string but got `%s`", jsonObj.get("properties").toString()));
          }

          // validate the optional field `properties` (array)
          for (int i = 0; i < jsonArrayproperties.size(); i++) {
            Property.validateJsonElement(jsonArrayproperties.get(i));
          };
        }
      }
      if (jsonObj.get("children") != null && !jsonObj.get("children").isJsonNull()) {
        JsonArray jsonArraychildren = jsonObj.getAsJsonArray("children");
        if (jsonArraychildren != null) {
          // ensure the json data is an array
          if (!jsonObj.get("children").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `children` to be an array in the JSON string but got `%s`", jsonObj.get("children").toString()));
          }

          // validate the optional field `children` (array)
          for (int i = 0; i < jsonArraychildren.size(); i++) {
            Concept.validateJsonElement(jsonArraychildren.get(i));
          };
        }
      }
      if (jsonObj.get("parents") != null && !jsonObj.get("parents").isJsonNull()) {
        JsonArray jsonArrayparents = jsonObj.getAsJsonArray("parents");
        if (jsonArrayparents != null) {
          // ensure the json data is an array
          if (!jsonObj.get("parents").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `parents` to be an array in the JSON string but got `%s`", jsonObj.get("parents").toString()));
          }

          // validate the optional field `parents` (array)
          for (int i = 0; i < jsonArrayparents.size(); i++) {
            Concept.validateJsonElement(jsonArrayparents.get(i));
          };
        }
      }
      if (jsonObj.get("descendants") != null && !jsonObj.get("descendants").isJsonNull()) {
        JsonArray jsonArraydescendants = jsonObj.getAsJsonArray("descendants");
        if (jsonArraydescendants != null) {
          // ensure the json data is an array
          if (!jsonObj.get("descendants").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `descendants` to be an array in the JSON string but got `%s`", jsonObj.get("descendants").toString()));
          }

          // validate the optional field `descendants` (array)
          for (int i = 0; i < jsonArraydescendants.size(); i++) {
            Concept.validateJsonElement(jsonArraydescendants.get(i));
          };
        }
      }
      if (jsonObj.get("associations") != null && !jsonObj.get("associations").isJsonNull()) {
        JsonArray jsonArrayassociations = jsonObj.getAsJsonArray("associations");
        if (jsonArrayassociations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("associations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `associations` to be an array in the JSON string but got `%s`", jsonObj.get("associations").toString()));
          }

          // validate the optional field `associations` (array)
          for (int i = 0; i < jsonArrayassociations.size(); i++) {
            Association.validateJsonElement(jsonArrayassociations.get(i));
          };
        }
      }
      if (jsonObj.get("inverseAssociations") != null && !jsonObj.get("inverseAssociations").isJsonNull()) {
        JsonArray jsonArrayinverseAssociations = jsonObj.getAsJsonArray("inverseAssociations");
        if (jsonArrayinverseAssociations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inverseAssociations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inverseAssociations` to be an array in the JSON string but got `%s`", jsonObj.get("inverseAssociations").toString()));
          }

          // validate the optional field `inverseAssociations` (array)
          for (int i = 0; i < jsonArrayinverseAssociations.size(); i++) {
            Association.validateJsonElement(jsonArrayinverseAssociations.get(i));
          };
        }
      }
      if (jsonObj.get("roles") != null && !jsonObj.get("roles").isJsonNull()) {
        JsonArray jsonArrayroles = jsonObj.getAsJsonArray("roles");
        if (jsonArrayroles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("roles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `roles` to be an array in the JSON string but got `%s`", jsonObj.get("roles").toString()));
          }

          // validate the optional field `roles` (array)
          for (int i = 0; i < jsonArrayroles.size(); i++) {
            Role.validateJsonElement(jsonArrayroles.get(i));
          };
        }
      }
      if (jsonObj.get("disjointWith") != null && !jsonObj.get("disjointWith").isJsonNull()) {
        JsonArray jsonArraydisjointWith = jsonObj.getAsJsonArray("disjointWith");
        if (jsonArraydisjointWith != null) {
          // ensure the json data is an array
          if (!jsonObj.get("disjointWith").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `disjointWith` to be an array in the JSON string but got `%s`", jsonObj.get("disjointWith").toString()));
          }

          // validate the optional field `disjointWith` (array)
          for (int i = 0; i < jsonArraydisjointWith.size(); i++) {
            DisjointWith.validateJsonElement(jsonArraydisjointWith.get(i));
          };
        }
      }
      if (jsonObj.get("inverseRoles") != null && !jsonObj.get("inverseRoles").isJsonNull()) {
        JsonArray jsonArrayinverseRoles = jsonObj.getAsJsonArray("inverseRoles");
        if (jsonArrayinverseRoles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inverseRoles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inverseRoles` to be an array in the JSON string but got `%s`", jsonObj.get("inverseRoles").toString()));
          }

          // validate the optional field `inverseRoles` (array)
          for (int i = 0; i < jsonArrayinverseRoles.size(); i++) {
            Role.validateJsonElement(jsonArrayinverseRoles.get(i));
          };
        }
      }
      if (jsonObj.get("history") != null && !jsonObj.get("history").isJsonNull()) {
        JsonArray jsonArrayhistory = jsonObj.getAsJsonArray("history");
        if (jsonArrayhistory != null) {
          // ensure the json data is an array
          if (!jsonObj.get("history").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `history` to be an array in the JSON string but got `%s`", jsonObj.get("history").toString()));
          }

          // validate the optional field `history` (array)
          for (int i = 0; i < jsonArrayhistory.size(); i++) {
            History.validateJsonElement(jsonArrayhistory.get(i));
          };
        }
      }
      if (jsonObj.get("maps") != null && !jsonObj.get("maps").isJsonNull()) {
        JsonArray jsonArraymaps = jsonObj.getAsJsonArray("maps");
        if (jsonArraymaps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("maps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `maps` to be an array in the JSON string but got `%s`", jsonObj.get("maps").toString()));
          }

          // validate the optional field `maps` (array)
          for (int i = 0; i < jsonArraymaps.size(); i++) {
            ConceptMap.validateJsonElement(jsonArraymaps.get(i));
          };
        }
      }
      // validate the optional field `paths`
      if (jsonObj.get("paths") != null && !jsonObj.get("paths").isJsonNull()) {
        Paths.validateJsonElement(jsonObj.get("paths"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Concept.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Concept' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Concept> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Concept.class));

       return (TypeAdapter<T>) new TypeAdapter<Concept>() {
           @Override
           public void write(JsonWriter out, Concept value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Concept read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Concept given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Concept
  * @throws IOException if the JSON string is invalid with respect to Concept
  */
  public static Concept fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Concept.class);
  }

 /**
  * Convert an instance of Concept to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

